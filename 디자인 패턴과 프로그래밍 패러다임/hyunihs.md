# 디자인 패턴
디자인 패턴이란, 프로그램을 설계할 때 발생했던 문제점들을 
객체 간의 상호 관계 등을 이용해 해결할 수 있도록 하나의 규약 형태로 만들어 놓은 것

## 싱글톤 패턴
- 하나의 클래스 기반으로 오직 하나의 인스턴스
- 보통 데이터베이스 연결 모듈에 많이 사용
### 장점
- 사용하기 쉽고 실용적이다
### 단점
- 모듈 간의 결합을 강하게 만든다
  - 의존성 주입 (DI, Dependency Injection) 통해 해결 (결합을 느슨하게 만듦)
- TDD(Test Driven Development) 할 때 단위 테스트 만들기 어렵다
  - 각 테스트마다 독립적인 인스턴스 만들어야 하는데 미리 생성된 하나의 인스턴스를 기반으로 구현하는 패턴이므로

### 의존성 주입
> A가 B에 의존성이 있다 = B의 변경 사항에 A도 변해야 한다

| 의존성 주입 X                | 의존성 주입 O                               |
|-------------------------|----------------------------------------|
| 메인 모듈이 직접 하위 모듈에 의존성 주기 | 의존성 주입자를 통해 메인 모듈이 간접적으로 하위 모듈에 의존성 주입 |

![image-3](https://github.com/CS-STUDY-17/CS-Study/assets/86969518/12c0372a-5d00-4e9a-b898-f965f22b334e)

#### 장점
- 모듈 간 결합 느슨해짐
- 테스팅, 마이그레이션 쉬워짐
- 일관된 의존성 방향, 모듈 간 명확한 관계, 쉽게 추론 가능: 유지 보수 쉬워짐

#### 단점
- 모듈 분리되며 클래스 수 늘어나 복잡해질 수 있음
- 약간의 린 타임 페널티

#### 원칙
- 상위 모듈은 하위 모듈에서 어떠한 것도 가져오지 말아야 한다
- 상위 모듈, 하위 모듈은 둘다 추상화에 의존해야 하며, 추상화는 세부 사항에 의존하지 말아야 한다


## 팩토리 패턴
- 객체 생성 부분을 떼어내 추상화
- 상속 관계에 있는 두 클래스에서 상위 클래스가 뼈대를 결정하고, 하위 클래스가 객체 생성에 관한 구체적인 내용을 결정
- 느슨한 결함 & 유연성 & 유지보수성

## 전략 패턴
- 전략 패턴 (strategy pattern) = 정책 패턴 (policy pattern)
- 전략 = '캡슐화한 알고리즘'
- 객체의 행위를 바꿀 때 직접 수정하지 않고 컨텍스트 내 전략을 바꿈

## 옵저버 패턴
- 주체가 어떤 객체(subject)의 상태 변화를 관찰하고 상태 변화가 있을 때마다 메서드 등을 통해 옵저버들에게 변화를 알려줌
- 주체와 관찰 객체의 구분 없이 하나의 객체가 두 역할을 하는 경우도 있다
- 트위터: 팔로워들에게 알림
- 이벤트 기반 시스템
- MVC 패턴: model의 변경사항 → 옵저버인 뷰에 알려줌 → 이를 기반으로 컨트롤러 작동

### 참고) 자바의 상속과 구현
- 상속(extends)
  - 자식 클래스가 부모 클래스의 메서드 상속받아 사용 (추가 및 확장 가능)
  - 일반 클래스, abstract 클래스 기반 구현
- 구현(implements)
  - 부모 인터페이스를 자식 클래스에서 재정의해 구현 (반드시)
  - 인터페이스 기반 구현

### 자바스크립트에서의 옵저버 패턴
- 프록시 객체 이용: 매개변수로 target, handler

## 프록시 패턴과 프록시 서버
### 프록시 패턴
- 대상 객체(subject)에 접근하기 전 그 접근에 대한 흐름을 가로채 대상 객체 앞단의 인터페이스 역할을 하는 디자인 패턴

### 프록시 서버
- 서버와 클라이언트 사이에서 클라이언트가 자신을 통해 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해주는 컴퓨터 시스템이나 응용 프로그램
- nginx: 비동기 이벤트 기반의 구조와 다수의 연결 효과적으로 처리하는 웹 프록시 서버
  - Node.js 앞단에 많이 둠
- CloudFlare: 웹 서버 앞단에 두고 DDOS 공격 방어나 HTTPS 구축에 쓰임
- 프론트엔드 서버 앞단에 프록시 서버를 두어 cors를 해결하기도 함 (포트 변경)

## 이터레이터 패턴
- 여러 자료형을 하나의 이터레이터로 순회 가능

## 노출 모듈 패턴
- 즉시 실행 함수를 통해 private, public 등의 접근 제어자를 만드는 패턴 (자바 스크립트는 접근 제어자가 존재하지 않아서 노출 모듈 패턴을 통해 구현하기도 함)

## MVC 패턴
- Model, View, Controller
- 재사용성과 확장성이 용이
- 애플리케이션이 복잡해질 수록 모델과 뷰의 관계가 복잡해짐
- Spring

![model-view-controller-light-blue](https://github.com/CS-STUDY-17/CS-Study/assets/86969518/a348d42c-7629-4fcc-9ca6-f90bcd3d158b)
> - Model: 데이터베이스, 상수, 변수 등 애플리케이션의 데이터
> - View: 사용자 인터페이스 (사용자가 보는 화면, 모델이 가지고 있는 정보 제외)
> - Controller: 이벤트 등 메인 로직을 담당, 모델과 뷰의 생명 주기 관리, 모델이나 뷰를 변경하고 알림

## MVP 패턴
- Controller 대신 Presenter
- View와 Presenter는 일대일 관계여서 MVC 패턴보다 더 강력한 결함을 지님

## MVVM 패턴
- Controller 대신 View Model(뷰를 더 추상화한 계층)
- 커맨드, 데이터 바인딩 (뷰와 뷰모델 사이의 양방향 데이터 바인딩 지원)
- UI를 별도의 코드 수정 없이 재사용 가능
- 단위 테스팅이 쉬움
- Vue.js (반응형이 특징인 프론트엔드 프레임워크)

![mvvm-pattern](https://github.com/CS-STUDY-17/CS-Study/assets/86969518/00ac1591-0538-4495-b0a1-72bd4f000c18)

# 프로그래밍 패러다임
프로그래머에게 프로그래밍의 관점을 갖게 해주는 개발 방법  
언어가 특정 패러다임을 지원하기도 하고(jdk 1.8 이전의 자바 - 객체지향, 하스켈 - 함수형),  
여러 패러다임을 지원하기도 함(C++, 파이썬, 자바스크립, 자바는 jdk 1.8 부터 함수형 및 선언형도 지원)
- 선언형
  - 함수형
- 명령형
  - 객체지향
  - 절차지향

어떤 것이 좋은지는 없고, 비즈니스 로직이나 서비스 특징 고려해서 패러다임을 정해야 한다  
상황에 따라 여러 패러다임을 조합하여 사용하는 것이 좋다

## 선언형과 함수형 프로그래밍
- Declarative Programming, Functional Programming
- '무엇을' 풀어내는가에 집중
- "프로그래밍은 함수로 이루어진 것이다"
- 순수 함수들을 블록처럼 쌓아 로직을 구현하고 고차 함수를 통해 재사용성을 높임
- 자바스크립트에서 주로 선호됨
- 커링, 불변성 등의 특징

## 객체지향 프로그래밍
- OOP, Object-Oriented Programming
- 객체들의 집합으로 프로그램의 상호 작용을 표현, 데이터를 객체로 취급해 객체 내부에 선언된 메서드를 활용
- 설계에 많은 시간이 소요되고 처리 속도가 상대적으로 느림

### 특징
- 추상화
- 캡슐화
- 상속성
- 다형성
  - 오버로딩
  - 오버라이딩

### 설계 원칙 (SOLID)
- S: 단일 책임 원칙 (Single Responsibility Principle)
  - 모든 클래스의 각각 하나의 책임만
- O: 개발-폐쇄 원칙 (Open CLosed Principle)
  - 기존의 코드는 잘 변경하지 않으면서 확장은 쉬워야
- L: 리스코프 치환 원칙 (Liskov Substitution Principle)
  - 부모 객체에 자식 객체 넣어도 문제 없이 돌아가야 (프로그램의 정확성을 꺠뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야)
- I: 인터페이스 분리 원칙 (Interface Segregation Principle)
  - 하나의 일반적인 인터페이스보다 구체적인 여러 개의 인터페이스를 만들어야 하는 원칙
- D: 의존 역전 원칙 (Dependency Inversion Principle)
  - 상위 계층은 하위 계층의 변화에 대한 구현으로부터 독립해야

## 절차형 프로그래밍
- 로직이 수행되어야 할 연속적인 계산 과정으로 이루어짐
- 코드의 가독성이 좋으며 실행 속도가 빠름
- 계산이 많은 작업 등에 쓰임
- fortran을 이용한 대기 과학 관련 연산 작업, 머신 러닝 배치 작업
- 모듈화하기 어렵고 유지 보수성이 떨어짐
