## SECTION 1 디자인 패턴

<aside>
💡 디자인 패턴이란?

디자인 패턴이란 프로그램을 설계할 때 발생했던 문제점들을 객체 간의 상호 관계 등을 이용하여 해결할 수 있도록 하나의 ‘규약’ 형태로 만들어 놓은 것

</aside>

### 1. 싱글톤 패턴(singleton pattern)

- 하나의 클래스가 오직 하나의 인스턴스만 가지는 패턴, 데이터베이스 연결 모듈에 많이 사용
    - 장점: 하나의 인스턴스를 다른 모듈들이 공유 → 인스턴스 생성 비용 줄어듦
    - 단점
        - TDD(Test Driven Developtment)에서 각 테스트마다 독립적인 인스턴스를 만들기 어려움
        - 모듈 간의 의존성이 높아짐
            - 의존성 주입을 통해 해결
        
        <aside>
        💡 의존성 주입(DI, Dependency Injection)
        
        상위 모듈이 직접 하위 모듈에 대한 의존성을 주지 않고 중간에 의존성 주입자(dependency injector)를 통해 간접적으로 의존성을 주입하는 방식 → 상위 모듈의 하위 모듈에 대한 의존성이 떨어짐
        
        - 장점: 테스팅과 마이그레이션 편리, 모듈간의 관계들이 명확해짐
        - 단점: 클래스 수가 늘어나 복잡성 증가, 런타임 패널티
        </aside>
        

### 2. 팩토리 패턴(factory pattern)

- 객체를 사용하는 코드에서 객체 생성 부분을 떼어내 추상화한 패턴
- 상속 관계에 있는 두 클래스에서 상위 클래스가 중요한 뼈대를 결정하고, 하위 클래스에서 객체 생성에 관한 구체적인 내용을 결정하는 패턴
- 상위 클래스와 하위 클래스가 분리되어 느슨한 결합을 가지고 유연성과 유지보수성이 높아짐

### 3. 전략 패턴(strategy pattern)

- 객체의 행위를 바꾸고 싶은 경우 직접 수정하지 않고 컨텍스트 내에서 전략만 바꿈

### 4. 옵저버 패턴(observer parttern)

- 주체가 어떤 객체의 상태 변화를 관찰하다가 상태 변화가 있을 때마다 메서드 등을 통해 옵저버 목록에 있는 옵저버들에게 변화를 알림
- 주체: 객체의 상태 변화를 보고 있는 관찰자
- 옵저버: 객체의 상태 변화에 따라 전달되는 메서드 등을 기반으로 추가 변화 사항이 생기는 객체들

### 5. 프록시 패턴과 프록시 서버

(1) 프록시 패턴(proxy pattern): 대상 객체에 접근하기 전 그 접근에 대한 흐름을 가로채 대상 객체 앞단의 인터페이스 역할을 하는 디자인 패턴

- 객체의 속성, 변환 등을 보완
- 보안, 데이트 검증, 캐싱, 로깅 등에 사용

(2) 프록시 서버(proxy server): 서버와 클라이언트 사이에서 클라이언트가 자신을 통해 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해주는 컴퓨터 시스템이나 응용 프로그램

- nginx: 비동기 이벤트 기반의 구조와 다수의 연결 효과적으로 처리하는 웹 서버
- CloudFlare: 웹 서버 앞단에 두고 DDOS 공격 방어나 HTTPS 구축
- 프론트엔드에서 프록시 서버를 만들어 cors 에러를 해결

### 6. 이터레이터 패턴(iterator pattern)

- 이터레이터를 사용하여 컬렉션의 요소들에 접근하는 디자인 패턴

### 7. 노출모듈 패턴(revealing module pattern)

- 즉시 실행 함수를 통해 `private`, `public` 같은 접근 제어자를 만드는 패턴

### 8. MVC 패턴

(1) MVC 패턴이란?

- 모델(Model), 뷰(View), 컨트롤러(Controller)로 이루어진 디자인 패턴
- 애플리케이션의 구성 요소를 세 가지 역할로 구분 → 개발 프로세스에서 각각의 구성 요소에만 집중

(2) 모델(Model): 애플리케이션의 데이터에 관한 모든 정보를 가짐

(3) 뷰(View): 사용자 인터페이스 요소로, 모델을 기반으로 사용자가 볼 수 있는 화면

(4) 컨트롤러(Controller)

- 하나 이상의 모델과 하나 이상의 뷰를 이어줌
- 메인 로직 담당
- 뷰를 통해 데이터를 생성하거나 수정하면 컨트롤러가 모델을 생성하거나 갱신함
- 모델과 뷰의 생명주기 관리

### 9. MVP 패턴

- MVC 패턴에서 C에 해당하는 컨트롤러가 프레젠터(Presenter)로 교체된 패턴
- 뷰와 프레젠터는 일대일 관계 → MVC 패턴 보다 강한 결합도

### 10. MVVM 패턴

- MVC 패턴에서 C에 해당하는 컨트롤러가 뷰모델(View Model)로 바뀐 패턴
- 뷰모델: 뷰를 더 추상화한 계층

## SECTION 2 프로그래밍 패러다임

<aside>
💡 프로그래밍 패러다임(programming paradigm)

프로그래머에게 프로그래밍의 관점을 갖게 해주는 역할을 하는 개발 방법론

![image](https://github.com/CS-STUDY-17/CS-Study/assets/77063375/e0df2694-e005-442f-a546-456c0533bf0c)


</aside>

### 1. 선언형과 함수형 프로그래밍

(1) 선언형 프로그래밍(declarative programming)

- ‘무엇을’ 풀어내는가에 집중한 패러다임
- 프로그램은 함수로 이루어진 것이다

(2) 함수형 프로그래밍(functional programming)

- 선언형 프로그래밍의 일종
- 순수 함수들을 블록처럼 쌓아 로직을 구현하고 고차 함수를 통해해 재사용성을 높인 프로그래밍 패러다임
    
    > 순수 함수: 출력이 입력에만 의존
    > 
    
    > 고차 함수: 함수가 함수를 값처럼 매개변수로 받아 로직을 생성할 수 있는 것
    > 

### 2. 객체지향 프로그래밍

(1) 객체지향 프로그래밍(OOP, Object-Oriented Programing)

- 객체들의 집합으로 프로그램의 상호 작용을 표현
- 데이터를 객체로 취급하여 객체 내부에서 선언된 메서드를 활용하는 방식

(2) 객체지향 프로그래밍의 특징

- **추상화(abstraction)**: 복잡한 시스템으로부터 핵심적인 개념 또는 기능을 간추려내는 것
- **캡슐화(encapsulation)**: 객체의 속성과 메서드를 하나로 묶고 일부를 외부로부터 감추어 은닉하는 것
- **상속성(inheritance)**: 상위 클래스의 특성을 하위 클래스가 이어받아서 재사용하거나 추가, 확장하는 것
- **다형성(polymorphism)**: 하나의 메서드가 다양한 방법으로 동작하는 것
    - 오버로딩
    - 오버라이딩

(3) 설계 원칙: **SOLID**

- **단일 책임 원칙(SRP, Single Responsibility Principle)**: ****한 클래스는 하나의 책임만 가져야함
- **개방-폐쇄 원칙(OCP, Open Closed Principle)**: 코드가 확장에는 열려있으나 변경에는 닫혀있어야 함
- **리스코프 치환 원칙(LSP, Liskov Substitution Principle):** 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 함
- **인터페이스 분리 원칙(ISP, Interface Segregation Principle)**: 하나의 일반적인 인터페이스보다 구체적인 여러 개의 인터페이스를 만들어야 함
- **의존 역전 원칙(DIP, Dependency Inversion Principle)**:  구현 클래스에 의존하지 말고 인터페이스에 의존해야함

### 3. 절차형 프로그래밍

- 로직이 수행되어야 할 연속적인 계산 과정으로 이루어져 있음
- 계산이 많은 작업 등에 쓰임
