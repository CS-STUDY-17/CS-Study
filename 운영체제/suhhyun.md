# 운영체제
## 운영체제와 컴퓨터
### 운영체제의 역할
1. CPU 스케줄링 및 프로세스 관리: CPU 소유권을 어떤 프로세스에 할당할지, 프로세스의 생성과 삭제, 자원 할당 및 반환 관리  
2. 메모리 관리: 한정된 메모리를 어떤 프로세스에 얼마나 할당할지 관리
3. 디스크 관리: 디스크 파일 보관 관리
4. I/O 디바이스 관리: 키보드, 마우스와 같은 I/O 디바이스와 컴퓨터 간에 데이터 주고받는 것을 관리

| 운영체제의 구조 |
|-----|
| 유저 프로그램 |
| GUI |
| 커널  |
| 드라이버 |
| 하드웨어 |

- GUI: 사용자가 장치와 상호작용할 수 있도록 하는 사용자 인터페이스의 한 형태
- 드라이버: 하드웨어 제어를 위한 소프트웨어
- CUI: 그래픽이 아닌 명령어로 처리하는 인터페이스  

#### 시스템콜
운영체제가 커널에 접근하기 위한 인터페이스
유저 프로그램이 운영체제 사용 -> 운영체제는 시스템콜을 통해 커널 함수 호출

ex. 파일 읽기 요청
유저 모드로 요청 -> 시스템콜 -> 커널 모드로 변경 -> 파일 읽기 수행
- 컴퓨터 자원에 직접적인 접근 차단
- 프로그램을 다른 프로그램으로 부터 보호

모드비트(modebit)
- 0: 커널 모드
- 1: 유저 모드

### 컴퓨터의 요소
- CPU
  - ALU + 제어장치 + 레지스터로 구성
    - ALU: 덧셈, 뺄셈, 논리곱 등 산술과 논리연산을 계산하는 디지털회로
    - 제어장치: 통신 제어, 명령 읽고 해석, 순서 결정
    - 레지스터: CPU 안의 매우 빠른 임시기억장치
  - 인터럽트에 의해 단순히 메모리에 저장된 명령을 해석하고 실행
    - 인터럽트: 신호가 들어왔을 때 CPU를 잠시 정지시키는 것
      - 하드웨어 인터럽트: I/O 디바이스에 의한 인터럽트
      - 소프트웨어 인터럽트(trap): 프로세스 오류로 인한 인터럽트
- RAM(메모리) & 메모리 컨트롤러: 기억을 담당, 메모리가 클수록 많은 일을 동시에 할 수 있음
- DMA 컨트롤러: I/O 디바이스가 메모리에 직접 접근 가능하게 함, CPU 보조일꾼
- 타이머: 특정 프로세스에 시간 제한을 둠
- 디바이스 컨트롤러 & 로컬 버퍼 & 디바이스

### 메모리
#### 메모리 계층
| 메모리 계층          |
|-----------------|
| 레지스터            |
| 캐시              |
| 메모리(RAM)/주기억장치  |
| 저장장치/보조기억장치     |
- 레지스터: CPU 내부의 작은 메모리  
- 보조기억장치: 비휘발성, HDD, SSD 등을 나타냄  

계층 구조를 두는 이유: 경제성 & 캐시  
캐시: 데이터를 미리 복사해 두는 임시 저장소 & 속도 차이에 따른 병목 현상을 줄이기 위한 메모리
* 캐싱 계층: 속도 차이를 해결하기 위해 계층과 계층 사이에 두는 계층

지역성
- 시간 지역성: 최근 사용한 데이터에 다시 접근하려는 특성
- 공간 지역성: 최근 접근한 데이터를 이루고 있는공간, 또는 그 가까운 공간에 접근하려는 특성

캐시매핑
- 직접 매핑
- 연관 매핑
- 집한 연관 매핑

웹 브라우저의 캐시
- 쿠키: 4KB, 만료기한 O
- 로컬 스토리지: 10MB, 만료기한 X
- 세션 스토리지: 5MB, 만료기한 X

#### 메모리 관리
- 가상 메모리: 디스크를 RAM의 보조기억장치 처럼 작동하게 해서 실행하는 기법, 프로세스가 실행될 때 전체가 메모리에 올라가지 않아도 실행이 가능  
가상 주소와 실제 주소 매핑, 프로세스의 주소 정보 담은 페이지 테이블로 관리
  - TLB: 주소 변환을 위한 캐시
- 스와핑:  페이지 폴트가 일어나면 메모리와 하드디스크의 영역을 교환
- 페이지 폴트: 가상메모리에는 존재하지만 메모리에는 존재하지 않는 데이터에 접근하려고 할 때
- 스레싱: 메모리의 페이지 폴트율이 높은 것을 의미,
  메모리에 너무 많은 프로세스가 동시에 올라가면 스와핑 발생률 증가  
-> 페이지 폴트 증가 = CPU 이용률 감소   
-> CPU가 한가하다고 착각하고 더 많은 프로세스를 메모리에 올림

- 메모리 할당
  - 연속 할당
    - 고정 분할 방식: 내부 단편화
    - 가변 분할 방식: 외부 단편화
      - 최초적합
      - 최적적합
      - 최악적합
  - 불연속 할당
    - 페이징 기법: 메모리를 동일한 크기의 페이지(보통 4KB)로 나누고 메모리의 서로 다른 위치에 프로그램 할당
    - 세그멘테이션: 의미 단위인 세그먼트로 나눔
    - 페이지드 세그멘테이션: 프로그램을 의미 단위인 세그먼트로 나눠 공유나 보안에서 이득, 동일한 크기의 페이지 단위로 나눔

페이지 교체 알고리즘
- 오프라인 알고리즘
- FIFO
- LRU: 참조가 가장 오래된 페이지 바꿈, 각 페이지마다 계수기, 스택 필요
- NUR(= clock alg)
- LFU: 가장 참조 횟수가 적은 페이지 교체

### 프로세스와 스레드
- 프로세스: 현재 실행되고 있는 프로그램(=태스크), 프로그램이 메모리에 올라가 인스턴스화 된 것을 뜻함
- 스레드: 프로세스 내 작업의 흐름

#### 프로그램의 컴파일 과정
<img src="https://velog.velcdn.com/images/narangke3/post/a9daf66d-aab5-41a7-b8c0-268b535ea7a2/image.png">  

- 정적 라이브러리
- 동적 라이브러리

#### 프로세스의 상태
- 생성 상태
- 대기 상태: CPU 소유권을 기다리는 상태
- 대기 중단 상태: 메모리 부족으로 일시 중단된 상태
- 실행 상태
- 중단 상태
- 일시 중단 상태: 중단 상태에서 프로세스가 실행되려고 했으나 메모리 부족으로 일시 중단된 상태
- 종료 상태

#### 프로세스의 메모리 구조
| 프로세스의 메모리 구조 |
|--------------|
| 스택        |
| 힙          |
| 데이터 영역   |
| 코드 영역     |

- 동적 영역
  - 스택: 지역 변수, 매개변수, 실행되는 함수 등 저장
  - 힙: 동적 할당 변수 저장
- 정적 영역
  - 데이터 영역: 전역 변수, static, const 선언 변수
  - 코드 영역

#### PCB
- PCB(Process Control Block): 프로세스의 메타데이터 저장, 프로세스 생성 시 함께 생성
- 컨텍스트 스위칭: 프로세스가 전환되며 PCB를 교환하는 과정  
  인터럽트 or 시스템콜 -> 프로세스 A의 PCB 저장 -> 프로세스 B의 PCB 로드 -> B 실행
  - 유휴시간 발생
  - 캐시미스 비용

#### 멀티 프로세싱
여러개의 프로세스를 동시에 실행  
- 공유 메모리: 여러 프로세스가 하나의 메모리를 공유해서 사용, 속도 빠르지만 동기화 필요
- 파일
- 소켓
- 익명 파이프
- 명명된 파이프
- 메시지 큐  

ex) 웹 브라우저

#### 스레드와 멀티스레딩
코드, 데이터, 힙 공유, 스택은 따로
멀티스레딩: 프로세스 내 작업을 여러 스레드가 동시에 처리, 
스레드는 자원을 공유하기 때문에 효율성 good, 
하나의 스레드가 중단되어도 다른 스레드가 처리 가능, 
but 스레드끼리 영향을 주고받음  
ex) 렌더러 프로세스

#### 공유자원과 임계영역
- 공유자원: 시스템 안에서 각 프로세스, 스레드가 함께 접근할 수 있는 자원이나 변수
- 경쟁상태: 공유자원을 두 개 이상의 프로세스가 동시에 읽거나 쓰는 상황
- 임계영역: 경쟁상태에서 스레드 접근 순서 등으로 인해 결과가 달라지는 코드 영역
  - 해결 방법: 상호 배제, 한정 대기, 융통성 만족해야 됨
    - 뮤텍스: 잠금/잠금해제 두 상태만을 가짐
    - 세마포어: wait&signal로 접근 처리
      - 바이너리 세마포어
      - 카운팅 세마포어
    - 모니터: 스레드나 프로세스가 공유 자원에 안전하게 접근하도록 자원을 숨기고 인터페이스만을 제공

#### 교착상태
- 교착상태: 두 개 이상의 프로세스들이 서로가 가진 자원을 기다리며 중단된 상태
  - 원인
    - 상호 배제
    - 점유 대기
    - 비선점
    - 환형 대기
  - 해결 방법
    - 애초에 조건이 성립되지 않도록 설계
    - 은행원 알고리즘 사용으로 교착 상태 가능성이 없을 때에만 자원 할당
    - 교착 상태 발생 시 사이클을 찾고 관련 프로세스를 하나씩 지움
    - 무시

### CPU 스케줄링 알고리즘
#### 비선점형 방식
- 프로세스가 스스로 CPU 소유권을 포기하는 방식, not 강제중지 -> 컨텍스트 스위칭으로 인한 부하 적음
- FCFS
- SJF: 실행시간이 가장 짧은 프로세스를 과거 경험을 토대로 추측하여 먼저 실행
  - 장점: 평균 대기 시간 짧음
  - 단점: starvation 가능
- 우선순위: SJF의 단점을 보완하여 오래된 작업에 가중치 부여 -> 우선순위 높임(aging)

#### 선점형 방식
- 현대 운영체제가 사용하는 방식, 현재 프로세스를 알고리즘에 의해 중단시키고 강제로 다른 프로세스에 CPU 소유권 할당
- 라운드 로빈: 우선순위 스케줄링의 일종, 각각 동일한 할당 시간 부여 후 맨 뒤로 보내는 방식
- SRF: SJF와 유사하나 중간에 더 짧은 시간의 작업이 들어오면 해당 프로세스로 전환
- 다단계 큐: 우선순위에 따른 준비 큐 여러개 & 각 큐마다 알고리즘 적용
  - 장점: 큐 간 프로세스 이동 X -> 스케줄링 부담 적음
  - 단점: 유연성 적음