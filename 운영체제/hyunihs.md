# 운영체제
> OS, Operating System  
> - 사용자가 컴퓨터를 쉽게 다루게 해주는 인터페이스
> - 한정된 메모리나 시스템 자원을 효율적으로 분배
> - 운영체제와 유사하지만 소프트웨어 추가 설치 불가 = 펌웨어(firmware)

## 운영체제와 컴퓨터
### 운영체제의 역할
1. CPU 스케줄링과 프로세스 관리
2. 메모리 관리
3. 디스크 파일 관리
4. I/O 디바이스 관리

### 운영체제의 구조
![R1280x0-2](https://github.com/CS-STUDY-17/CS-Study/assets/86969518/3ad3a92d-318e-4c38-8312-b73d08863fc7)
- GUI 없이 CUI만 있는 리눅스 서버도 있음
- 인터페이스: 사용자가 전자 장치와 상호작용할 수 있도록 해줌
  - GUI: Graphical User Interface
  - CUI: Character User Interface  
    그래픽이 아닌 명령어로 처리
- 드라이버: 하드웨어를 제어하기 위한 소프트웨어
- 커널: 운영체제의 핵심적 부분, 시스템콜 인터페이스 제공
  - 보안, 메모리, 프로세스, 파일 시스템, I/O 디바이스, I/O 요청 관리

#### 시스템콜
- 운영체제가 커널에 접근하기 위한 인터페이스
- 유저 프로그램이 운영체제의 서비스를 받기 위해 커널 함수 호출 시 사용
- 컴퓨터 자원에 대한 직접 접근 차단할 수 있음
- 프로그램을 다른 프로그램으로부터 보호할 수 있음
- 하나의 추상화 계층: 낮은 단계의 영역 처리에 대한 부분을 많이 신경쓰지 않고 프로그램 구현 가능

![R1280x0-3](https://github.com/CS-STUDY-17/CS-Study/assets/86969518/996df27a-50a8-40ce-88f3-f4ed6a82909f)
![R1280x0-4](https://github.com/CS-STUDY-17/CS-Study/assets/86969518/5ddbd214-b156-4af3-a971-684580624a7b)

- modebit: 0은 커널모드, 1은 유저모드 (모드 구분하는 flag bit)
  - 유저 모드: 유저가 접근할 수 있는 영역 제한적으로 두며 컴퓨터 자원 함부로 침범 X
  - 커널 모드: 모든 컴퓨터 자원에 접근할 수 있는 모드

> 카메라, 키보드 등 I/O 디바이스는 운영체제를 통해서만 작동해야 한다. (커널 모드에서만)
> 유저 모드에서 작동된다면, 사용자가 의도하지 않았는데 공격자가 카메라를 갑자기 켤 수 있는 등 일이 일어날 수 있음

![process-kennel-devices](https://github.com/CS-STUDY-17/CS-Study/assets/86969518/abee73ac-db10-4d93-8da8-841bef3e1736)

### 컴퓨터의 요소
#### CPU
- Central Processing Unit
- 인터럽트에 의해 단순히 메모리에 존재하는 명령어를 해석해서 실행
- 운영체제 → 커널 → HDD 또는 SDD에 있는 프로그램을 메모리(RAM)에 올려 프로세스로 만듦 → CPU가 처리
- 산술논리 연산장치
  - ALU, Arithmetic Logic Unit
  - 산술연산(덧셈, 뺄셈 등)과 논리 연산(논리합, 논리곱) 계산하는 디지털 회로
- 제어장치
  - CU, Control Unit
  - 프로세스 조작 지시: 입출력장치간 통신 제어, 명령어 읽고 해석, 데이터 처리 순서 결정
- 레지스터
  - 매우 빠른 임시기억 장치
  - CPU 안에 있으므로 연산 속도가 메모리보다 수십~수백 배 빠름
  - CPU는 자체적으로 데이터 저장할 방법이 없으므로 레지스터 거쳐 데이터 전달함

![image-4](https://github.com/CS-STUDY-17/CS-Study/assets/86969518/db2fba24-bcb0-4f69-8725-0bf09f0e61cb)

- 인터럽트: 어떤 신호가 들어왔을 때 CPU 잠깐 정지시키는 것
  - 하드웨어 인터럽트
    - I/O 디바이스에서 발생 (키보드 연결, 마우스 연결 등)
    - 인터럽트 라인 설계, 순차적인 인터럽트 실행 중지, 시스템콜 요청, 원하는 디바이스의 로컬 버퍼 접근해 일 수행
  - 소프트웨어 인터럽트(=trap, 트랩)
    - 프로세스 오류 등으로 프로세스가 시스템콜 호출할 때 발동
  
#### DMA 컨트롤러
- I/O 디바이스가 메모리에 직접 접근할 수 있도록 하는 하드웨어 장치
- CPU 부하 막아주며 CPU 일 부담하는 보조 일꾼
- 하나의 작업을 CPU와 DMA 컨트롤러가 동시에 하는 것을 방지

#### 메모리
- RAM, Random Access Memory
- 데이터, 상태, 명령어 등을 기록

#### 타이머
- 몇 초 안에는 작업이 끝나야 한다는 것을 정함 (특정 프로그램에 시간 제한 달기)
- 시간이 많이 걸리는 프로그램에 제한 걸기 위해 존재

#### 디바이스 컨트롤러
- 컴퓨터와 연결되어 있는 I/O 디바이스들의 작은 CPU
- 옆에 붙어 있는 로컬 버퍼: 각 디바이스에서 데이터를 임시로 저장하기 위한 작은 메모리

## 메모리
- CPU는 메모리에 올라와 있는 프로그램의 명령어들을 실행할 뿐

### 메모리 계층
![메모리계층](https://github.com/CS-STUDY-17/CS-Study/assets/86969518/4d9b0fb5-f69a-4468-9ce7-63e4c5e1cef4)
- 레지스터: CPU 안에 있는 작은 메모리, 휘발성
- 캐시: L1, L2 캐시 지칭, 휘발성 (참고로 L3 캐시도 있음)
- 주기억장치: RAM(메모리) 지칭, 휘발성
  - 램은 하드디스크로부터 일정량 데이터 복사해 임시 저장하고 필요 시마다 CPU에 빠르게 전달하는 역할
- 보조기억장치: HDD, SSD 지칭, 비휘발성

> 계층이 있는 이유: 경제성과 캐시 때문

> 일상 속 예시: 게임 실행하다 '로딩 중' 뜰 때 → 하드디스크 또는 인터넷에서 데이터 읽어 RAM으로 전송하는 과정 중

#### 캐시
- 데이터를 미리 복사해 놓는 임시 저장소이자 빠른 장치와 느린 장치에서 속도 차이에 따른 병목 현상을 줄이기 위한 메모리
- 데이터 접근 시간 오래 걸리는 경우 해결, 무언가를 다시 계산하는 시간 절약
- 캐시 계층: 속도 차이 해결 위해 계층과 계층 사이에 있는 계층
  - ex1) 메모리와 CPU 사이 레지스터
  - ex2) 캐시 메모리와 보조기억장치(하드 디스크 등) 사이에 있는 주기억장치(메모리)
- 캐시를 직접 설정: 자주 사용하는 데이터를 기반으로 설정해야 → 지역성을 근거로
  - 시간 지역성 (temporal locality) : 최근 사용한 데이터에 다시 접근 하려는 특성
  - 공간 지역성 (spatial locality) : 최근 접근한 데이터를 이루고 있는 공간이나 그 근처에 접근하는 특성

<br>

- 캐시 히트: 캐시에서 원하는 데이터 찾음
  - 제어장치 거쳐 데이터 가져욤
  - 위치 가깝고 CPU 내부 버스 기반 = 빠름
- 캐시 미스: 못 찾아서 주 메모리로 가서 찾아옴
  - 시스테 버스 기반 = 느림

<br>

- 캐시가 히트되기 위해 매핑하는 방법
- CPU의 레지스터와 주메모리(RAM) 간에 데이터를 주고받을 때를 기반으로 설명
  - 직접 매핑
  - 연관 매핑
  - 집합 연관 매핑

#### 웹 브라우저의 캐시
- 쿠키
  - 만료기한이 있는 키-값 저장소, 4KB까지
  - 만료기한은 클라이언트, 서버 둘다 정할 수 있는데 보통 서버에서 정함
  - same site 옵션 strict 아닐 경우 다른 도메인에서 요청했을 때 자동 전송
  - document.cookie로 쿠키 볼 수 없게 httponly 옵션 거는 것이 중요
- 로컬 스토리지
  - 만료기한이 없는 키-값 저장소, 10MB까지
  - 도메인 단위로 저장, 생성 (웹 브라우저 닫아도 유지)
  - 클라이언트에서만 수정 가능
- 세션 스토리지
  - 만료기한이 없는 키-값 저장소, 5MB까지
  - 탭 단위, 탭 단으면 데이터 삭제
  - 클라이언트에서만 수정 가능

#### 데이터베이스의 캐싱 계층
메인 DB위에 Redis DB를 캐싱 계층으로 두어 성능을 향상시키기도 함

### 메모리 관리
운영체제의 역할 중 하나

#### 가상 메모리 (virtual memory)
![01](https://github.com/CS-STUDY-17/CS-Study/assets/86969518/1d94af5a-659a-41f4-826b-473bdf58c7ce)
- 가상 주소 (logical memory)
- 실제 주소 (physical memory)
- 메모리 관리 장치 (MMU): 가상주소를 실제 주소로 변환 → 사용자는 실제 주소 의식 없이 프로그램 구축
- 페이지(page): 가상 메모리를 사용하는 최소 크기 단위
- 프레임(frame): 실제 메모리를 사용하는 최소 크기 단위

<br>

![image-5](https://github.com/CS-STUDY-17/CS-Study/assets/86969518/af4673d5-f5ff-4f6d-b3ce-0ad3ed96490d)
- 페이지 테이블: 가상주소와 실제 주소가 매핑됨, 프로세스의 주요 정보 들어있음
- TLB: 속도 향상 위한 캐시 계층 (페이지 테이블의 리스트 보관)

<br>

- 페이지 폴트 (page fault): 프로세스의 주소 공간에는 존재하지만 지금 이 컴퓨터의 RAM에는 없는 데이터에 접근했을 경우
- 스와핑: 페이지 폴트가 발생했을 때 메모리에서 당장 사용하지 않는 영역을 하드디스크로 옮기고 하드디스크의 일부분을 마치 메모리처럼 불러와 쓰는 것

#### 스레싱 (thrashing)
- 메모리의 페이지 폴트율이 높음 (컴퓨터의 심각한 성능 저하 초래)
- 메모리에 너무 많은 프로세스 → 스와핑이 많이 일어남 → CPU 이용률 낮아짐 → 더 많은 프로세스 → 악순환, 스레싱 발생
- 해결 방안:
  - 메모리 증가
  - HDD를 SSD로 바꾸기
  - 운영체제에서 해결
    - 작업 세트: 프로세스의 과거 사용 이력인 지역성(locality) 통해 페이지 집합 만들어서 미리 메모리에 로드
    - PFF(Page Fault Frequency): 페이지 폴트 빈도의 상한선(도달 시 프레임 늘리기), 하한선(도달 시 프레임 줄이기) 둠
#### 메모리 할당
프로그램 할당 시 시작 메모리 위치, 메모리의 할당 크기 기반으로 할당
- 연속 할당
  - 고정 분할 방식: 메모리를 미리 나누어 관리
    - 내부 단편화 발생
    ![R1280x0-8](https://github.com/CS-STUDY-17/CS-Study/assets/86969518/9dbce0a1-287b-4a58-8760-55309318d67b)
  - 가변 분할 방식: 매 시점 프로그램의 크기에 맞게 동적으로 메모리 나눔
    - 내부 단편화 X, 외부 단편화 O
    ![R1280x0-7](https://github.com/CS-STUDY-17/CS-Study/assets/86969518/e6965fb3-aff0-40ee-8720-a92b8f839747)
    - 종류: 최초적합(first fit), 최적적합(best fit), 최악적합(worst fit)
      > 최초적합: 위쪽이나 아래쪽부터 첫번째 찾은 홀에 할당  
        최적적합: 프로세스의 크기 이상인 공간 중 가장 작은 홀에 할당  
        최악적합: 프로세스의 크기와 가장 많이 차이가 나는 홀(프로세스의 크기 이상인 공간 중 가장 큰 홀)에 할당
- 불연속 할당
  - 페이징: 동일한 크기의 페이지 단위로 나누어서 메모리의 서로 다른 위치에 프로세스 할당
    - 홀의 크기가 균일하지 않은 문제 없음
    - 주소 변환이 복잡함
  - 세그멘테이션: 페이지 단위가 아닌 의미 단위인 세그먼트로 나눔
    - 공유와 보안 측면 좋음
    - 홀 크기가 균일하지 않음
  - 페이지드 세그멘테이션: 페이징 + 세그멘테이션 (임의 단위인 세그먼트로 나누고 동일한 크기의 페이지 단위로 나눔)
#### 페이지 교체 알고리즘
> 스와핑은 페이지 교체 알고리즘을 기반으로 일어남   
> 스와핑은 많이 일어나지 않도록 설계되어야 (한정된 메모리 -> 스와핑 일어날 수밖에 없음)
- 오프라인 알고리즘: 먼 미래에 참조되는 페이지와 현재 할당하는 페이지를 swap
  - 불가능한 알고리즘이지만 성능 비교 시 upper bound로 사용됨
- FIFO (First In First Out)
- LRU (Least Recently Used)
  - 오래됨 파악 위해 각 페이지마다 계수기, 스택 두어야 하는 문제점
  - 프로그래밍으로 구현 시 **해시테이블**(이중 연결 리스트에서 빠른 검색 위해), **이중 연결 리스트**(한정된 메모리 나타냄)로 구현함
- NUR (Not Used Recently)
  - clock 알고리즘, 0/1 비트 이용
- LFU (Least Frequently Used)

## 프로세스와 스레드
> 프로세스:
> - 컴퓨터에서 실행되고 있는 프로그램
> - 프로그램이 메모리에 올라가 인스턴스화 된 것
> - CPU 스케쥴링의 대상이 되는 작업(task)이라는 용어와 거의 같은 의미

> 스레드: 프로세스 내 작업의 흐름

### 프로세스와 컴파일 과정
<img width="744" alt="image-6" src="https://github.com/CS-STUDY-17/CS-Study/assets/86969518/ab19f4ca-73e1-4ff5-aa1b-1e19ff29ba4e">

- 전처리: 소스코드의 주석 제거, 헤더파일 병합해 매크로 치환
- 컴파일러: 오류 처리, 코드 최적화 작업하며 어셈블리어로 변환
- 어셈블러: 목적 코드(object code)로 변환
  - ex) .c → .o (확장자 운영체제마다 다른데 리눅스는 .o)
- 링커: 프로그램 내에 있는 라이브러리 함수 또는 다른 파일들과 목적코드를 결합해 실행 파일 만듦 (.exe, .out 등)

> - 정적 라이브러리: 프로그램 빌드 시 라이브러리가 제공하는 모든 코드를 실행 파일에 넣음
>   - 외부 의존도 ↓, 메모리 효율성 ↓
> - 동적 라이브러리: 프로그램 실행 시 필요할 때만 DLL이라는 함수 정보를 통해 참조해 라이브러리 사용
>   - 외부 의존도 ↑, 메모리 효율성 ↑

### 프로세스의 상태
#### 생성 상태 (create)
- 프로세스가 생성된 상태
- fork(), exec()
- PCB 할당

#### 대기 상태 (ready)
- 메모리 공간이 충분하지 않을 때 대기하며 CPU 스케쥴러로부터 CPU 소유권이 넘어오기를 기다리는 상태
- 메모리 공간이 충분하면 메모리 할당받음

#### 대기 중단 상태 (ready suspended)
- 메모리 부족으로 일시 중단된 상태

#### 실행 상태 (running)
- CPU 소유권과 메모리 할당받고 인스트럭션을 수행 중인 상태
- CPU burst가 일어난 상태

#### 중단 상태 (blocked)
- 어떤 이벤트 발생 후 기다리며 프로세스가 차단된 상태
- I/O 디바이스에 의한 인터럽트로 많이 발생함
  - ex) 프린트 인쇄 버튼 눌렀을 때 프로세스 잠깐 멈춤

#### 일시 중단 상태 (blocked suspended)
- 중단된 상태에서 프로세스가 실행되려고 했지만 메모리 부족으로 일시 중단된 상태

#### 종료 상태 (terminated)
- 메모리와 CPU 소유권을 모두 놓고 가는 상태
1. 자연스럽게 종료 
2. 부모 프로세스가 자식 프로세스를 강제 종료 (abort)
   - 자식 프로세스에 할당된 자원의 한계치를 넘을 경우
   - 부모 프로세스가 종료될 경우
   - 사용자가 process.kill 등 여러 명령어로 종료시킬 경우

### 프로세스의 메모리 구조
![1*fwkyPI8Gmzd0Q_XAGM5_eA](https://github.com/CS-STUDY-17/CS-Study/assets/86969518/a19d1922-f6fb-4a6b-8f67-79aaf11977a4)
- 스택 / 힙 / 데이터 영역 (BSS segment, Data segment), 코드 영역

#### 스택과 힙
- 동적 할당 (런타임 단계에서 메모리 할당받음)
- 스택은 위 주소부터 할당, 힙은 아래 주소부터 할당
- 스택: 지역 변수, 매개변수, 실행되는 함수에 의해 늘어나고 줄어드는 메모리 영역
  - 함수 호출 시 호출될 때의 환경 등 정보가 스택에 저장됨
  - 재귀 함수 호출 시 새로운 스택 프레임 매번 사용 (함수 내의 변수 집합이 해당 함수의 다른 인스턴스 변수 방해하지 않음)
- 힙: 동적으로 할당되는 변수 담음
  - malloc(), free()
  - 동적으로 관리되는 자료구조가 힙 사용 ex) vector

#### 데이터 영역과 코드 영역
- 정적 할당 (컴파일 단계에서 메모리 할당)
- BSS segment: 전역 변수 또는 static, const로 선언되어 있고 0으로 초기화 또는 초기화되지 않은 변수들
- Data segment: 전역 변수 또는 static, const로 선언되어 있고 0이 아닌 값으로 초기화된 변수들
- code segment (text segment): 프로그램의 코드

### PCB (Process Control Block, 프로세스 제어 블록)
- 운영체제에서 프로세스에 대한 메타데이터를 저장한 '데이터'
- 프로세스가 생성되면 운영체제는 해당 PCB를 생성
- 일반 사용자가 접근하지 못하도록 (중요한 정보이므로) 커널 스택의 가장 앞부분에서 관리

#### PCB의 구조
- 프로세스 스케줄링 상태
- 프로세스 ID
- 프로세스 권한
- 프로그램 카운터
- CPU 레지스터
- CPU 스케줄링 정보
- 계정 정보
- I/O 상태 정보

#### 컨텍스트 스위칭
- PCB를 교환하는 과정
- 한 프로세스에 할당된 시간이 끝나거나 인터럽트에 의해 발생
- 한 시점에 한 프로그램 실행(싱글코어 CPU, 많은 프로세스가 동시에 구돝되는 것처럼 보이는 것은 컨텍스트 스위칭 일어나기 때문
  - 멀티코어 CPU면 그만큼 많은 프로그램 한번에 실행 가능
- 유휴 시간 (idle time) 발생
- 캐시 미스 발생
  - 컨텍스트 스위칭 시  프로세스가 가지고 있는 메모리 주소가 그대로면 잘못된 주소 변환이 생기므로 캐시클리어 시행
- 스레드에서도 일어남
  - 스레드는 스택 영역을 제외한 모든 메모리 공유 → 비용, 시간 더 적게 걸림

### 멀티 프로세싱
- 웹 브라우저 
#### IPC (Inter Process Communication)
> 프로세스끼리 데이터를 주고받고 공유 데이터를 관리하는 메커니즘  
> ex) 클라이언트 & 서버

- 공유 메모리
- 파일
- 소켓
- 익명 파이프
- 명명 파이프
- 메시지 큐

### 스레드와 멀티스레딩
- 스레드는 프로세스의 실행 가능한 가장 작은 단위
  - 프로세스는 여러 스레드 가질 수 있음
- 멀티스레딩: 프로세스 내 작업을 여러 스레드로 처리
  - 장점:
    - 스레드끼리 서로 자원 공유해 효율적임
    - 한 스레드가 중단되어도 다른 스레드는 실행 상태일 수 있으므로 무중단 빠른 처리 가능
    - 동시성에도 장점
  - 단점:
    - 한 스레드에 문제가 생기면 다른 스레드에도 영향을 끼쳐 스레드로 이루어져 있는 프로세스에 영향을 줄 수 있음

### 공유 자원과 임계 영역
#### 공유 자원(shared resource)
- 시스템 안에서 각 프로세스, 스레드가 함께 접근할 수 있는 모니터, 프린터, 메모리, 파일, 데이터 등의 자원이나 변수
- 경쟁상태(race condition): 공유 자원을 두 개 이상의 프로세스가 동시에 읽거나 쓰는 상황
  - 결괏값에 영향을 줄 수 있음

#### 임계 영역(critical section)
- 둘 이상의 프로세스, 스레드가 공유 자원에 접근할 때 순서 등의 이유로 결과가 달라지는 코드 영역
- 해결방법: 상호 배제, 한정 대기, 융통성 조건 만족함
  - 뮤텍스
  - 세마포어
  - 모니터

### 교챡 상태 (deadlock)
- 두 개 이상의 프로세스들이 서로가 가진 자원을 기다리며 중단된 상태

#### 원인
- 상호 배제
- 점유 대기
- 비선점
- 환형 대기

#### 해결 방법
1. 자원을 할당할 때 애초에 조건이 성립되지 않도록 설계
2. 은행원 알고리즘
3. 교착 상태가 발생하면 사이클이 있는지 찾아보고 이에 관련된 프로세스를 하나씩 지움
4. 사용자가 작업 종료 (현대 운영체제는 이 방법 채택, 매우 드물게 일어나기 때문에 처리 비용이 더 크기 때문)요

## CPU 스케줄링 알고리즘
> - CPU 이용률이 높게
> - 주어진 시간에 많은 일을 하게
> - 준비 큐(ready queue)에 있는 프로세스는 적게
> - 응답 시간은 짧게

### 비선점형(non-preemptive) 방식
프로세스가 스스로 CPU 소유권을 포기하는 방식  
강제로 프로세스를 중지하지 않음 → 컨텍스트 스위칭으로 인한 부하가 적음

#### FCFS
- First Come, First Served
- 길게 수행되는 프로세스 때문에 convoy effect(준비 큐에서 오래 기다리는 현상) 발생

#### SJF
- Shortest Job First
- starvation(긴 시간을 가진 프로세스가 실행되지 않는 현상) 발생
- 평균 대기 시간 가장 짧음
- 실제로는 실행 시간 알 수 없으므로 과거 실행했던 시간 토대로 추측함

#### 우선순위
- SJF 스케줄링의 starvation 해결: 오래된 작업일 수록 우선순위를 높임 (aging)

### 선점형(preemtive) 방식
현대 운영체제가 쓰는 방식  
지금 사용하고 있는 프로세스를 알고리즘에 의해 중단시키고 강제로 다른 프로세스에 CPU 소유권 할당

#### 라운드 로빈(RR, Round Robin)
- 현대 컴퓨터가 쓰는 스케줄링인 우선순위 스케줄링의 일종
- 각 프로세스마다 동일한 할당 시간 주고 그 시간 안에 끝나지 않으면 다시 ready queue의 뒤로
- 할당 시간 너무 크면 FCFS가 되고, 너무 짧으면 컨텍스트 스위칭이 잦아져 오버헤드가 커짐
- 일반적으로 전체 작업 시간은 길어지지만 평균 응답 시간은 짧아짐
- 로드밸런서에서 트래픽 분산 알고리즘으로도 쓰임

#### SRF
- Shortest Remaining Time First
- 프로세스 실행 중간에 실행시간이 더 짧은 작업이 들어오면 수행하던 프로세스 중지하고 해당 프로세스 수행 (SJF는 하던거 완료하고 다음 작업)

#### 다단계 큐
- 우선순위에 따른 ready queue 여러 개
  - 높은 우선순위 큐, 중간 우선순위 큐, 낮은 우선순위 큐 등
- 큐마다 다른 스케줄링 알고리즘 적용
- 큐 간 프로세스 이동이 안돼서 스케줄링 부담이 적지만 유연성이 떨어짐

