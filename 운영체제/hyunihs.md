# 운영체제
> OS, Operating System  
> - 사용자가 컴퓨터를 쉽게 다루게 해주는 인터페이스
> - 한정된 메모리나 시스템 자원을 효율적으로 분배
> - 운영체제와 유사하지만 소프트웨어 추가 설치 불가 = 펌웨어(firmware)

## 운영체제와 컴퓨터
### 운영체제의 역할
1. CPU 스케줄링과 프로세스 관리
2. 메모리 관리
3. 디스크 파일 관리
4. I/O 디바이스 관리

### 운영체제의 구조
![R1280x0-2](https://github.com/CS-STUDY-17/CS-Study/assets/86969518/3ad3a92d-318e-4c38-8312-b73d08863fc7)
- GUI 없이 CUI만 있는 리눅스 서버도 있음
- 인터페이스: 사용자가 전자 장치와 상호작용할 수 있도록 해줌
  - GUI: Graphical User Interface
  - CUI: Character User Interface  
    그래픽이 아닌 명령어로 처리
- 드라이버: 하드웨어를 제어하기 위한 소프트웨어
- 커널: 운영체제의 핵심적 부분, 시스템콜 인터페이스 제공
  - 보안, 메모리, 프로세스, 파일 시스템, I/O 디바이스, I/O 요청 관리

#### 시스템콜
- 운영체제가 커널에 접근하기 위한 인터페이스
- 유저 프로그램이 운영체제의 서비스를 받기 위해 커널 함수 호출 시 사용
- 컴퓨터 자원에 대한 직접 접근 차단할 수 있음
- 프로그램을 다른 프로그램으로부터 보호할 수 있음
- 하나의 추상화 계층: 낮은 단계의 영역 처리에 대한 부분을 많이 신경쓰지 않고 프로그램 구현 가능

![R1280x0-3](https://github.com/CS-STUDY-17/CS-Study/assets/86969518/996df27a-50a8-40ce-88f3-f4ed6a82909f)
![R1280x0-4](https://github.com/CS-STUDY-17/CS-Study/assets/86969518/5ddbd214-b156-4af3-a971-684580624a7b)

- modebit: 0은 커널모드, 1은 유저모드 (모드 구분하는 flag bit)
  - 유저 모드: 유저가 접근할 수 있는 영역 제한적으로 두며 컴퓨터 자원 함부로 침범 X
  - 커널 모드: 모든 컴퓨터 자원에 접근할 수 있는 모드

> 카메라, 키보드 등 I/O 디바이스는 운영체제를 통해서만 작동해야 한다. (커널 모드에서만)
> 유저 모드에서 작동된다면, 사용자가 의도하지 않았는데 공격자가 카메라를 갑자기 켤 수 있는 등 일이 일어날 수 있음

![process-kennel-devices](https://github.com/CS-STUDY-17/CS-Study/assets/86969518/abee73ac-db10-4d93-8da8-841bef3e1736)

### 컴퓨터의 요소
#### CPU
- Central Processing Unit
- 인터럽트에 의해 단순히 메모리에 존재하는 명령어를 해석해서 실행
- 운영체제 → 커널 → HDD 또는 SDD에 있는 프로그램을 메모리(RAM)에 올려 프로세스로 만듦 → CPU가 처리
- 산술논리 연산장치
  - ALU, Arithmetic Logic Unit
  - 산술연산(덧셈, 뺄셈 등)과 논리 연산(논리합, 논리곱) 계산하는 디지털 회로
- 제어장치
  - CU, Control Unit
  - 프로세스 조작 지시: 입출력장치간 통신 제어, 명령어 읽고 해석, 데이터 처리 순서 결정
- 레지스터
  - 매우 빠른 임시기억 장치
  - CPU 안에 있으므로 연산 속도가 메모리보다 수십~수백 배 빠름
  - CPU는 자체적으로 데이터 저장할 방법이 없으므로 레지스터 거쳐 데이터 전달함

![image-4](https://github.com/CS-STUDY-17/CS-Study/assets/86969518/db2fba24-bcb0-4f69-8725-0bf09f0e61cb)

- 인터럽트: 어떤 신호가 들어왔을 때 CPU 잠깐 정지시키는 것
  - 하드웨어 인터럽트
    - I/O 디바이스에서 발생 (키보드 연결, 마우스 연결 등)
    - 인터럽트 라인 설계, 순차적인 인터럽트 실행 중지, 시스템콜 요청, 원하는 디바이스의 로컬 버퍼 접근해 일 수행
  - 소프트웨어 인터럽트(=trap, 트랩)
    - 프로세스 오류 등으로 프로세스가 시스템콜 호출할 때 발동
  
#### DMA 컨트롤러
- I/O 디바이스가 메모리에 직접 접근할 수 있도록 하는 하드웨어 장치
- CPU 부하 막아주며 CPU 일 부담하는 보조 일꾼
- 하나의 작업을 CPU와 DMA 컨트롤러가 동시에 하는 것을 방지

#### 메모리
- RAM, Random Access Memory
- 데이터, 상태, 명령어 등을 기록

#### 타이머
- 몇 초 안에는 작업이 끝나야 한다는 것을 정함 (특정 프로그램에 시간 제한 달기)
- 시간이 많이 걸리는 프로그램에 제한 걸기 위해 존재

#### 디바이스 컨트롤러
- 컴퓨터와 연결되어 있는 I/O 디바이스들의 작은 CPU
- 옆에 붙어 있는 로컬 버퍼: 각 디바이스에서 데이터를 임시로 저장하기 위한 작은 메모리

## 메모리
- CPU는 메모리에 올라와 있는 프로그램의 명령어들을 실행할 뿐

### 메모리 계층
![메모리계층](https://github.com/CS-STUDY-17/CS-Study/assets/86969518/4d9b0fb5-f69a-4468-9ce7-63e4c5e1cef4)
- 레지스터: CPU 안에 있는 작은 메모리, 휘발성
- 캐시: L1, L2 캐시 지칭, 휘발성 (참고로 L3 캐시도 있음)
- 주기억장치: RAM(메모리) 지칭, 휘발성
  - 램은 하드디스크로부터 일정량 데이터 복사해 임시 저장하고 필요 시마다 CPU에 빠르게 전달하는 역할
- 보조기억장치: HDD, SSD 지칭, 비휘발성

> 계층이 있는 이유: 경제성과 캐시 때문

> 일상 속 예시: 게임 실행하다 '로딩 중' 뜰 때 → 하드디스크 또는 인터넷에서 데이터 읽어 RAM으로 전송하는 과정 중

#### 캐시
- 데이터를 미리 복사해 놓는 임시 저장소이자 빠른 장치와 느린 장치에서 속도 차이에 따른 병목 현상을 줄이기 위한 메모리
- 데이터 접근 시간 오래 걸리는 경우 해결, 무언가를 다시 계산하는 시간 절약
- 캐시 계층: 속도 차이 해결 위해 계층과 계층 사이에 있는 계층
  - ex1) 메모리와 CPU 사이 레지스터
  - ex2) 캐시 메모리와 보조기억장치(하드 디스크 등) 사이에 있는 주기억장치(메모리)
- 캐시를 직접 설정: 자주 사용하는 데이터를 기반으로 설정해야 → 지역성을 근거로
  - 시간 지역성 (temporal locality) : 최근 사용한 데이터에 다시 접근 하려는 특성
  - 공간 지역성 (spatial locality) : 최근 접근한 데이터를 이루고 있는 공간이나 그 근처에 접근하는 특성

<br>

- 캐시 히트: 캐시에서 원하는 데이터 찾음
  - 제어장치 거쳐 데이터 가져욤
  - 위치 가깝고 CPU 내부 버스 기반 = 빠름
- 캐시 미스: 못 찾아서 주 메모리로 가서 찾아옴
  - 시스테 버스 기반 = 느림

<br>

- 캐시가 히트되기 위해 매핑하는 방법
- CPU의 레지스터와 주메모리(RAM) 간에 데이터를 주고받을 때를 기반으로 설명
  - 직접 매핑
  - 연관 매핑
  - 집합 연관 매핑

#### 웹 브라우저의 캐시
- 쿠키
  - 만료기한이 있는 키-값 저장소, 4KB까지
  - 만료기한은 클라이언트, 서버 둘다 정할 수 있는데 보통 서버에서 정함
  - same site 옵션 strict 아닐 경우 다른 도메인에서 요청했을 때 자동 전송
  - document.cookie로 쿠키 볼 수 없게 httponly 옵션 거는 것이 중요
- 로컬 스토리지
  - 만료기한이 없는 키-값 저장소, 10MB까지
  - 도메인 단위로 저장, 생성 (웹 브라우저 닫아도 유지)
  - 클라이언트에서만 수정 가능
- 세션 스토리지
  - 만료기한이 없는 키-값 저장소, 5MB까지
  - 탭 단위, 탭 단으면 데이터 삭제
  - 클라이언트에서만 수정 가능

#### 데이터베이스의 캐싱 계층
메인 DB위에 Redis DB를 캐싱 계층으로 두어 성능을 향상시키기도 함

### 메모리 관리
운영체제의 역할 중 하나

#### 가상 메모리 (virtual memory)
![01](https://github.com/CS-STUDY-17/CS-Study/assets/86969518/1d94af5a-659a-41f4-826b-473bdf58c7ce)
- 가상 주소 (logical memory)
- 실제 주소 (physical memory)
- 메모리 관리 장치 (MMU): 가상주소를 실제 주소로 변환 → 사용자는 실제 주소 의식 없이 프로그램 구축
- 페이지(page): 가상 메모리를 사용하는 최소 크기 단위
- 프레임(frame): 실제 메모리를 사용하는 최소 크기 단위

<br>

![image-5](https://github.com/CS-STUDY-17/CS-Study/assets/86969518/af4673d5-f5ff-4f6d-b3ce-0ad3ed96490d)
- 페이지 테이블: 가상주소와 실제 주소가 매핑됨, 프로세스의 주요 정보 들어있음
- TLB: 속도 향상 위한 캐시 계층 (페이지 테이블의 리스트 보관)

<br>

- 페이지 폴트 (page fault): 프로세스의 주소 공간에는 존재하지만 지금 이 컴퓨터의 RAM에는 없는 데이터에 접근했을 경우
- 스와핑: 페이지 폴트가 발생했을 때 메모리에서 당장 사용하지 않는 영역을 하드디스크로 옮기고 하드디스크의 일부분을 마치 메모리처럼 불러와 쓰는 것

#### 스레싱 (thrashing)
- 메모리의 페이지 폴트율이 높음 (컴퓨터의 심각한 성능 저하 초래)
- 메모리에 너무 많은 프로세스 → 스와핑이 많이 일어남 → CPU 이용률 낮아짐 → 더 많은 프로세스 → 악순환, 스레싱 발생
- 해결 방안:
  - 메모리 증가
  - HDD를 SSD로 바꾸기
  - 운영체제에서 해결
    - 작업 세트: 프로세스의 과거 사용 이력인 지역성(locality) 통해 페이지 집합 만들어서 미리 메모리에 로드
    - PFF(Page Fault Frequency): 페이지 폴트 빈도의 상한선(도달 시 프레임 늘리기), 하한선(도달 시 프레임 줄이기) 둠
#### 메모리 할당
프로그램 할당 시 시작 메모리 위치, 메모리의 할당 크기 기반으로 할당
- 연속 할당
  - 고정 분할 방식: 메모리를 미리 나누어 관리
    - 내부 단편화 발생
    ![R1280x0-8](https://github.com/CS-STUDY-17/CS-Study/assets/86969518/9dbce0a1-287b-4a58-8760-55309318d67b)
  - 가변 분할 방식: 매 시점 프로그램의 크기에 맞게 동적으로 메모리 나눔
    - 내부 단편화 X, 외부 단편화 O
    ![R1280x0-7](https://github.com/CS-STUDY-17/CS-Study/assets/86969518/e6965fb3-aff0-40ee-8720-a92b8f839747)
    - 종류: 최초적합(first fit), 최적적합(best fit), 최악적합(worst fit)
      > 최초적합: 위쪽이나 아래쪽부터 첫번째 찾은 홀에 할당  
        최적적합: 프로세스의 크기 이상인 공간 중 가장 작은 홀에 할당  
        최악적합: 프로세스의 크기와 가장 많이 차이가 나는 홀(프로세스의 크기 이상인 공간 중 가장 큰 홀)에 할당
- 불연속 할당
  - 페이징: 동일한 크기의 페이지 단위로 나누어서 메모리의 서로 다른 위치에 프로세스 할당
    - 홀의 크기가 균일하지 않은 문제 없음
    - 주소 변환이 복잡함
  - 세그멘테이션: 페이지 단위가 아닌 의미 단위인 세그먼트로 나눔
    - 공유와 보안 측면 좋음
    - 홀 크기가 균일하지 않음
  - 페이지드 세그멘테이션: 페이징 + 세그멘테이션 (임의 단위인 세그먼트로 나누고 동일한 크기의 페이지 단위로 나눔)
#### 페이지 교체 알고리즘
> 스와핑은 페이지 교체 알고리즘을 기반으로 일어남   
> 스와핑은 많이 일어나지 않도록 설계되어야 (한정된 메모리 -> 스와핑 일어날 수밖에 없음)
- 오프라인 알고리즘: 먼 미래에 참조되는 페이지와 현재 할당하는 페이지를 swap
  - 불가능한 알고리즘이지만 성능 비교 시 upper bound로 사용됨
- FIFO (First In First Out)
- LRU (Least Recently Used)
  - 오래됨 파악 위해 각 페이지마다 계수기, 스택 두어야 하는 문제점
  - 프로그래밍으로 구현 시 **해시테이블**(이중 연결 리스트에서 빠른 검색 위해), **이중 연결 리스트**(한정된 메모리 나타냄)로 구현함
- NUR (Not Used Recently)
  - clock 알고리즘, 0/1 비트 이용
- LFU (Least Frequently Used)
