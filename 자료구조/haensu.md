## SECTION 1 복잡도

### 1. 시간 복잡도

- 문제를 해결하는 데 걸리는 시간과 입력의 함수 관계
- 어떠한 알고리즘의 로직이 얼마나 오랜 시간이 걸리는지 나타냄 → 효율적인 코드로 개선하기 위해 사용
- 빅오 표기법: 입력 범위 n을 기준으로 해서 로직이 몇 번 반복되는지 나타냄
    - 가장 영향을 많이 끼치는 항의 상수 인자를 빼고 나머지 항을 없앰
        
        ex) O(n^2)
        

### 2. 공간 복잡도

- 프로그램을 실행시켰을 때 필요로 하는 자원 공간의 양
    
    ex) int a[1004]; → 1004 * 4 바이트의 공간 차지
    
- 재귀적인 함수로 인해 공간을 계속해서 필요로 할 경우도 포함

### 3. 자료구조에서의 시간 복잡도

(1) 자료 구조의 평균 시간 복잡도

| 자료 구조 | 접근 | 탐색 | 삽입 | 삭제 |
| --- | --- | --- | --- | --- |
| 배열 | O(1) | O(n) | O(n) | O(n) |
| 스택 | O(n) | O(n) | O(1) | O(1) |
| 큐 | O(n) | O(n) | O(1) | O(1) |
| 이중 연결 리스트 | O(n) | O(n) | O(1) | O(1) |
| 해시 테이블 | O(1) | O(1) | O(1) | O(1) |
| 이진 탐색 트리 | O(logn) | O(logn) | O(logn) | O(logn) |
| AVL 트리 | O(logn) | O(logn) | O(logn) | O(logn) |
| 레드 블랙 트리 | O(logn) | O(logn) | O(logn) | O(logn) |

(2) 자료 구조의 최악의 시간 복잡도

| 자료 구조 | 접근 | 탐색 | 삽입 | 삭제 |
| --- | --- | --- | --- | --- |
| 배열 | O(1) | O(n) | O(n) | O(n) |
| 스택 | O(n) | O(n) | O(1) | O(1) |
| 큐 | O(n) | O(n) | O(1) | O(1) |
| 이중 연결 리스트 | O(n) | O(n) | O(1) | O(1) |
| 해시 테이블 | O(n) | O(n) | O(n) | O(n) |
| 이진 탐색 트리 | O(n) | O(n) | O(n) | O(n) |
| AVL 트리 | O(logn) | O(logn) | O(logn) | O(logn) |
| 레드 블랙 트리 | O(logn) | O(logn) | O(logn) | O(logn) |

<br>
<br>

## SECTION 2 선형 자료 구조

### 1. 연결 리스트

- 데이터를 감싼 노드를 포인터로 연결
- 가장 앞에 있는 노드는 `head`
- 함수
    - `push_front()`: 맨 앞에 요소 삽입
    - `push_back()`: 맨 뒤에 요소 삽입
    - `insert()`: 중간에 요소 삽입
    
    <img width="718" alt="image" src="https://github.com/CS-STUDY-17/CS-Study/assets/77063375/f4ac377a-d309-47d1-bce4-4a612b404179">


### 2. 배열

- 같은 타입의 변수들로 이루어져 있고, 크기가 정해져 있으며 인접한 메모리 위치에 있는 데이터를 모아놓은 집합
- 중복을 허용, 순서 존재, 랜덤 접근 가능

### 3. 벡터

- 동적으로 요소를 할당할 수 있는 동적 배열
- 중복 허용, 랜덤 접근 가능
- 함수
    - `push_back()`
    - `pop_back()`
    - `erase()`
    - `find()`
    - `clear()`
    

### 4. 스택

- LIFO
- 재귀적인 함수, 알고리즘, 웹 브라우저 방문 기록 등에 사용

### 5. 큐

- FIFO
- CPU 스케줄링, 스레드 행렬, 네트워크 접속 행렬, 너비 우선 탐색, 캐시 등에 사용
