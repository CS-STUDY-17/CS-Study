## SECTION 1 복잡도

### 1. 시간 복잡도

- 문제를 해결하는 데 걸리는 시간과 입력의 함수 관계
- 어떠한 알고리즘의 로직이 얼마나 오랜 시간이 걸리는지 나타냄 → 효율적인 코드로 개선하기 위해 사용
- 빅오 표기법: 입력 범위 n을 기준으로 해서 로직이 몇 번 반복되는지 나타냄
    - 가장 영향을 많이 끼치는 항의 상수 인자를 빼고 나머지 항을 없앰
        
        ex) O(n^2)
        

### 2. 공간 복잡도

- 프로그램을 실행시켰을 때 필요로 하는 자원 공간의 양
    
    ex) int a[1004]; → 1004 * 4 바이트의 공간 차지
    
- 재귀적인 함수로 인해 공간을 계속해서 필요로 할 경우도 포함

### 3. 자료구조에서의 시간 복잡도

(1) 자료 구조의 평균 시간 복잡도

| 자료 구조 | 접근 | 탐색 | 삽입 | 삭제 |
| --- | --- | --- | --- | --- |
| 배열 | O(1) | O(n) | O(n) | O(n) |
| 스택 | O(n) | O(n) | O(1) | O(1) |
| 큐 | O(n) | O(n) | O(1) | O(1) |
| 이중 연결 리스트 | O(n) | O(n) | O(1) | O(1) |
| 해시 테이블 | O(1) | O(1) | O(1) | O(1) |
| 이진 탐색 트리 | O(logn) | O(logn) | O(logn) | O(logn) |
| AVL 트리 | O(logn) | O(logn) | O(logn) | O(logn) |
| 레드 블랙 트리 | O(logn) | O(logn) | O(logn) | O(logn) |

(2) 자료 구조의 최악의 시간 복잡도

| 자료 구조 | 접근 | 탐색 | 삽입 | 삭제 |
| --- | --- | --- | --- | --- |
| 배열 | O(1) | O(n) | O(n) | O(n) |
| 스택 | O(n) | O(n) | O(1) | O(1) |
| 큐 | O(n) | O(n) | O(1) | O(1) |
| 이중 연결 리스트 | O(n) | O(n) | O(1) | O(1) |
| 해시 테이블 | O(n) | O(n) | O(n) | O(n) |
| 이진 탐색 트리 | O(n) | O(n) | O(n) | O(n) |
| AVL 트리 | O(logn) | O(logn) | O(logn) | O(logn) |
| 레드 블랙 트리 | O(logn) | O(logn) | O(logn) | O(logn) |

<br>
<br>

## SECTION 2 선형 자료 구조

### 1. 연결 리스트

- 데이터를 감싼 노드를 포인터로 연결
- 가장 앞에 있는 노드는 `head`
- 함수
    - `push_front()`: 맨 앞에 요소 삽입
    - `push_back()`: 맨 뒤에 요소 삽입
    - `insert()`: 중간에 요소 삽입
    
    <img width="718" alt="image" src="https://github.com/CS-STUDY-17/CS-Study/assets/77063375/f4ac377a-d309-47d1-bce4-4a612b404179">


### 2. 배열

- 같은 타입의 변수들로 이루어져 있고, 크기가 정해져 있으며 인접한 메모리 위치에 있는 데이터를 모아놓은 집합
- 중복을 허용, 순서 존재, 랜덤 접근 가능

### 3. 벡터

- 동적으로 요소를 할당할 수 있는 동적 배열
- 중복 허용, 랜덤 접근 가능
- 함수
    - `push_back()`
    - `pop_back()`
    - `erase()`
    - `find()`
    - `clear()`
    

### 4. 스택

- LIFO
- 재귀적인 함수, 알고리즘, 웹 브라우저 방문 기록 등에 사용

### 5. 큐

- FIFO
- CPU 스케줄링, 스레드 행렬, 네트워크 접속 행렬, 너비 우선 탐색, 캐시 등에 사용

<br>
<br>

## SECTION 3 비선형 자료 구조

### 1. 그래프

- 정점(vertex)과 간선(edge)으로 이루어진 자료 구조
- 가중치: 간선과 정점 사이에 드는 비용
    
    <img width="507" alt="image" src="https://github.com/CS-STUDY-17/CS-Study/assets/77063375/a198b17c-7916-47eb-b963-e8fe7b3af94f">

    

### 2. 트리

(1) 트리의 특징

- 그래프의 일종으로 트리 구조로 배열된 계층적 데이터의 집합
    - 부모, 자식 계층 구조를 가짐
- 간선 수(E) = 노드 수(V) - 1
- 임의의 두 노드 사이의 경로는 반드시 존재함
- 트리의 구성
    - 루트 노드: 가장 위에 있는 노드
    - 내부 노드: 루트 노드와 내부 노드 사이에 있는 노드
    - 리프 노드: 자식 노드가 없는 노드
- 트리의 높이와 레벨
    - 깊이: 루트 노드부터 특정 노드까지의 최단 거리
    - 높이: 루트 노드부터 리프 노드까지의 최장 거리
    - 레벨: 깊이와 같은 의미
    - 서브트리: 트리 내의 하위 집합

(2) **이진 트리**: 자식 노드 수가 두 개 이하인 트리

- 정이진 트리(full binary tree): 자식 노드가 0 또는 두 개인 이진 트리
- 완전 이진 트리(complete binary tree): 왼쪽에서부터 채워져 있는 이진 트리, 마지막 레벨을 제외하고는 모든 레벨이 완전히 채워져 있음
- 변질 이진 트리(degenerate binary tree): 자식 노드가 하나밖에 없는 이진 트리
- 포화 이진 트리(perfect binary tree): 모든 노드가 꽉 차 있는 이진 트리
- 균형 이진 트리(balanced binary tree): 왼쪽과 오른쪽 노드의 높이 차이가 1 이하인 이진 트리

<img width="718" alt="image" src="https://github.com/CS-STUDY-17/CS-Study/assets/77063375/7152f1d0-a708-47e6-8e76-4be307b5f765">


(3) **이진 탐색 트리(binary search tree, BST)**: 오른쪽 하위 트리에는 노드 값보다 큰 값이 있는 노드만 포함되고, 왼쪽 하위 트리에는 노드 값 보다 작거나 같은 값이 있는 노드만 포함하는 트리

(4) **AVL 트리**: 최악의 경우 선형적인 트리가 되는 것을 방지하고 스스로 균형을 잡는 이진 탐색 트리

- 두 자식 서브트리의 높이는 항상 최대 1 만큼 차이 남
- 삽입, 삭제를 할 때마다 균형을 잡기 위해 트리 일부를 왼쪽 혹은 오른쪽으로 회전시키며 균형을 잡음

(5) **레드 블랙 트리**: 균형 이진 탐색 트리로 각 노드는 빨간색 또는 검은색의 색상을 나타내는 추가 비트를 저장

- 모든 리프 노드와 루트 노드는 블랙이고 어떤 노드가 레드이면 그 노드의 자식은 반드시 블랙
- set, map 등의 자료구조를 구현

### 3. 힙

- 완전 이진 트리 기반의 자료 구조
- 최대 : 부모 노드에 있는 키는 모든 자식 노드에 있는 키 중에서 가장 커야함
- 최소 힙: 부모 노드에 있는 키는 모든 자식 노드에 있는 키 중에서 가장 작아야함

### 4. 우선순위 큐

- 대기열에서 우선순위가 높은 요소가 우선순위가 낮은 요소보다 먼저 제공되는 자료 궂
- 힙을 기반으로 구현
- `greater` → 오름차순, `less` → 내림차순

### 5. 맵

- 특정 순서에 따라 키와 매핑된 값의 조합으로 형성된 자료 구조
- 해시 테이블을 구현할 때 사용
- unordered_map은 정렬을 보장하지 않음
- `map<string, int>` 일 때 string → first(key), int → second(value)
- 함수
    - `clear()`
    - `size()`
    - `erase()`
    

### 6. 셋

- 특정 순서에 따라 고유한 요소를 저장하는 컨테이너
- 중복 허용 x

### 7. 해시 테이블

- 무한에 가까운 데이터들을 유한한 개수의 해시 값으로 매핑한 테이블
- unordered_map으로 구현
