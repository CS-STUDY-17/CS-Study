# 네트워크
## 네트워크의 기초
> 네트워크란 노드와 링크가 연결되어 있으며 리소스를 공유하는 집합이다
- 노드: 서버, 라우터, 스위치 등
- 링크: 유선 or 무선
### 처리량과 지연 시간
- 처리량(throughput)
  -  링크 내에서 성공적으로 전달된 데이터의 양 
  - bps(bits per second)
- 대역폭(bandwidth)
  - 주어진 시간 동안 네트워크 연결을 통해 흐를 수 있는 최대 비트 수
<p>
<img src ="https://github.com/CS-STUDY-17/CS-Study/assets/86969518/a9f4a72a-fed6-42a4-8334-2e3927b224e4" width="40%">
<img src="https://github.com/CS-STUDY-17/CS-Study/assets/86969518/3864e149-e432-4486-9166-26a4b032ba07" width="40%">
</p>

- 지연 시간(latency)
  - 어떤 메시지가 두 장치 사이를 왕복하는데 걸린 시간 (요청이 처리되는 시간)

### 네트워크 토폴로지와 병목 현상
#### 네트워크 토폴로지
> 네트워크 토폴로지(network topology)는 노드와 링크가 어떻게 배치되어 있는지에 대한 방식이자 연결 형태
- 트리 토폴로지 (tree topology)
  - 계층형 토폴로지
  - +) 노드의 추가, 삭제가 쉬움
  - -) 특정 노드에 트래픽이 집중될 때 하위 노드에 영향 가능
- 버스 토폴로지 (bus topology)
  - 중앙 통신 회선 하나에 여러 개의 노드 연결되어 공유
  - 근거리 통신망(LAN)에서 사용됨
  - +) 설치 비용 적음
  - +) 신뢰성 우수
  - +) 노드 추가 삭제 쉬움
  - -) **스푸핑**
  > 스푸핑이란 스위칭 기능을 마비시키거나 속여서 패킷을 수신부 대신 악의적인 노드에 전달하게 하는 것
- 스타 토폴로지 (start topology)
  - +) 노드 추가 쉬움
  - +) 에러 탐지 쉬움 (어떠한 노드에 장애가 발생해도), 장애 노드가 중앙 노드가 아닐 경우 다른 노드에 영향 적게 끼침
  - +) 패킷 충돌 가능성 적음
  - -) 중앙 노드에 장애 발생 시 전체 네트워크 사용 불가
  - -) 설치 비용 비쌈
- 링형 토폴로지 (ring topology)
  - 하나의 연속된 길을 통해 통신
  - +) 노드 수 증가해도 네트워크 상 손실 거의 없음
  - +) 충돌 발생 가능성 적음
  - +) 노드의 고장 발견을 쉽게 찾을 수 있음
  - -) 네트워크 구성 변경 어려움
  - -) 회선에 장애 발생 시 전체 네트워크에 영향
- 메시 토폴로지 (mesh topology)
  - +) 한 단말 장치에 장애 발생해도 여러 개 경로 존재하므로 네트워크 계속 사용 가능
  - +) 트래픽 분산 처리 가능
  - -) 노드 추가 어려움
  - -) 구축 비용과 운용 비용 비쌈

![network-topology-types-diagram](https://github.com/CS-STUDY-17/CS-Study/assets/86969518/02532022-b88e-47c7-afdb-bf07a45db311)


#### 병목(bottleneck) 현상
> 시스템의 CPU나 메모리, 디스크 등 자원 중 하나가 다른 자원들에 비해 처리 속도가 느려서, 전체적인 성능을 제한하는 경우

네트워크 토폴로지가 중요한 이유:   
병목 현상을 찾을 때 중요한 기준이 된다.  
네트워크의 토폴로지와 경로를 알아야 병목 현상을 올바르게 해결할 수 있다 

해결:
- Throughput 개선
- Latency 개선
- 회선 추가 (토폴로지에 맞게)

### 네트워크 분류
| 종류                | 범위                | 전송 속도       | 혼잡도       |
|-------------------|---------------------|-----------------|--------------|
| LAN (근거리 통신망)     | 같은 건물, 캠퍼스 내 | 빠름            | 낮음         |
| MAN (대도시 지역 네트워크) | 도시                | 중간            | 중간         |
| WAN (광역 네트워크)     | 국가 또는 대륙       | 낮음            | 높음         |

### 네트워크 성능 분석 명령어
- ping [ ip 주소 or 도메인 주소 ]
  - 대상 노드를 향해 일정 크기의 패킷 전송
  - 노드의 패킷 수신 상태, 도달하기까지 시간, 해당 노드까지 네트워크 잘 연결되어 있나 확인
  - ICMP 프로토콜을 통해 동작
  
  
<img width="462" alt="스크린샷 2023-10-12 오후 3 30 50" src="https://github.com/CS-STUDY-17/CS-Study/assets/86969518/cd73ab2c-2112-477b-ae71-344159bcb301">

- netstat
  - 접속되어 있는 서비스들의 네트워크 상태 표시
  - 네트워크 접속, 라우팅 테이블, 네트워크 프로토콜 리스트
  - 주로 서비스의 포트가 열려있나 확인할 때 사용

<img width="559" alt="스크린샷 2023-10-12 오후 3 33 15" src="https://github.com/CS-STUDY-17/CS-Study/assets/86969518/cd7bd3bc-a3cc-4bfb-8af3-9fd5fdb06752">

- nslookup
  - DNS 관련 확인 (도메인에 매핑된 ip 확인)

<img width="368" alt="스크린샷 2023-10-12 오후 3 34 36" src="https://github.com/CS-STUDY-17/CS-Study/assets/86969518/86076e1c-591b-46c4-b935-481ad7ea9e91">

- tracert / traceroute (윈도우/리눅스) [ ip 주소 or 도메인 주소 ]
  - 목적지 노드까지 네트워크 경로
  - 어느 구간에서 응답 시간이 느려지는지 등 확인 가능

<img width="555" alt="스크린샷 2023-10-12 오후 3 36 21" src="https://github.com/CS-STUDY-17/CS-Study/assets/86969518/6345a5d0-729f-408f-bc91-776e3ecad104">

### 네트워크 프로토콜 표준화
> 네트워크 프로토콜이란 다른 장치들끼리 데이터를 주고받기 위해 설정된 공통된 인터페이스를 말합니다
- IEEE, IETF 등의 표준화 단체에서 정의
- IEEE802.3: 유선 LAN 프로토콜 (Ethernet)
- IEEE802.11: 무선 LAN 프로토콜 (Wireless Network)

## TCP/IP 4계층 모델
인터넷 프로토콜 스위트(internet protocol suite)는 인터넷에서 컴퓨터들이 서로 정보를 주고받는 데 쓰이는
프로토콜의 집합  
주로 TCP/IP 4계층 모델 또는 OSI 7계층 모델로 설명한다

### 계층 구조
- OSI 7계층과 비교

![계층 구조](https://github.com/CS-STUDY-17/CS-Study/assets/86969518/079d6b14-d8ce-4939-b81e-baf0b61b7dea)

- 이 계층들은 특정 계층이 변경되었을 때 다른 계층이 영향을 받지 않도록 설계됨

#### 애플리케이션(application) 계층
- 응용프로그램이 사용되는 프로토콜 계층
- 웹 서비스, 이메일 등 서비스를 실질적으로 사람들에게 제공함
- 응용프로그램 예시
  - FTP: 파일 전송 표준 통신 프로토콜
  - SSH: 암호화 네트워크 프로토콜
  - HTTP: World Wide Web을 위한 데이터 통신의 기초이자 웹 사이트를 이용하는 데 쓰는 프로토콜
  - SMTP: 전자 메일 전송을 위한 인터넷 표준 통신 프로토콜
  - DNS: 도메인 이름과 ip 주소를 매칭해주는 서버, 이를 통해 ip 주소가 바뀌어도 같은 도메인 주소로 서비스 가능
    - ex) www.naver.com 에 DNS 쿼리 오면:
    - [Root DNS] -> [.com DNS] -> [.naver DNS] -> [.www DNS] (완벽한 주소 찾아 ip 매핑)

#### 전송(transport) 계층
- 송신자와 수신자 연결하는 통신 서비스 제공
- 어플리케이션과 인터넷 계층 사이의 데이터 전달될 때 중계 역할
- TCP, UDP

#### TCP

- 가상회선 패킷 교환 방식 (Virtual Circuit Packet Switching)
  - 각 패킷에 가상회선 식별자 포함
  - 모든 패킷 전송시 가상회선 해제
  - 패킷은 전송 순서대로 도착
  - 이전에 있던 Circuit Switching, Packet Switching의 단점을 보완해 나옴
- 패킷 사이 순서 보장
- 연결 지향 프로토콜 사용해 연결 (신뢰성)
- 수신 여부 확인
- 패킷 전송 보장되어야 하는 웹서버 등에서 이용

<br>

#### TCP 연결 성립
- 3-way handshake → 신뢰성 구축 → 데이터 전송 시작
- TCP는 이 과정이 있어서 신뢰성 있는 계층
- UDP는 이 과정이 없어서 신뢰성 없는 계층

![3wayhandshake](https://github.com/CS-STUDY-17/CS-Study/assets/86969518/72ae6b9f-b71d-4d0b-af29-3c1225f44340)

1. SYN: 클라이언트의 ISN을 담아 서버에 SYN을 보냄  
  ISN은 새로운 TCP 연결의 첫번째 패킷에 할당된 임의의 시퀀스 번호 (장치마다 다를 수 있음)
2. SYN + ACK: 서버는 클라이언트의 SYN을 수신하고 서버의 ISN을 보내며 승인번호로 클라이언트의 ISN + 1 을 보냄
3. ACK: 클라이언트는 서버의 ISN + 1 한 값인 승인번호를 담아 서버에 ACK을 보냄

#### TCP 연결 해제 과정
- 4-way handshake

![99229C485C1D90C038](https://github.com/CS-STUDY-17/CS-Study/assets/86969518/77f654be-d517-4c83-a576-32e26e13e68d)

> TIME_WAIT: 그냥 연결을 닫으면 되지 왜 굳이 일정 시간 뒤에 닫을까?  
> ** 소켓이 소멸되지 않고 일정 시간 유지되는 상태, OS마다 유지 시간 좀 다름
1. 지연 패킷이 발생할 경우 대비
   - 패킷이 뒤늦게 도달하고 이를 처리하지 못한다면 데이터 무결성 문제가 발생 (전체가 아니라 일부 데이터만 들어오는 현상)
2. 두 장치가 연결이 닫혔는지 확인
   - LASK_ACK 상태에서 닫히게 되면 다시 새로운 뎐결을 하려고 할 때 장치는 줄곧 LASK_ACK으로 되어 있기 떄문에 접속 오류가 날 것

#### UDP
- 데이터그램 패킷 교환 방식
  - 패킷이 독립적으로 이동하며 최적의 경로를 선택
  - 하나의 메시지에서 분할된 여러 패킷이 서로 다른 경로로 전송될 수 있음
- 순서 보장 X
- 수신 여부 확인 X
- 오디오 통신 등에서 사용

#### 인터넷(internet) 계층
- 장치로부터 받은 네트워크 패킷을 ip 주소로 지정된 목적지로 전송하기 위해 사용되는 계층
- IP, ARP, ICMP 등
- 패킷을 수신해야 할 상대의 주소를 지정해 데이터 전달
- 상대가 제대로 받았는지에 대해는 보장 X (비연결형적 특징)

#### 링크(link) 계층 (네트워크 접근 계층)
- 전선, 광섬유, 무선 등 실질적으로 데이터 전달하고 장치 간에 신호를 주고받는 '규칙'을 정하는 계층
- 물리계층: 무선 LAN, 유선 LAN을 통해 0과 1로 이루어진 데이터를 보내는 계층
- 데이터 링크 계층: '이더넷 프레임'을 통해 에러 확인, 흐름 제어, 접근 제어를 담당하는 계층

#### 유선 LAN (IEEE802.3)
- 전이중화(full duplex) 통신
  - 양쪽 장치가 동시에 송수신할 수 있는 방식 (송신로 수신로 나눠서 데이터 주고받음)
  - 현대의 고속 이더넷은 이 방식을 기반으로 통신
- CSMA/CD
  - 반이중화 통신, 이전에 유선 LAN에 쓰던 방식
  - 데이터를 <b>보낸 이후</b> 충돌이 발생한다면 일정 시간 이휴 재전송 (Carrier Sense Multiple Access with Collision Detection)
  - 송신로 수신로 나누어지지 않고 한 경로 기반으로 데이터 보냄 (보낼 때 충돌에 대비해야)
- 유선 LAN 이루는 케이블: 트위스트 페어(TP) 케이블, 광섬유 케이블
  - 트위스트 페어 케이블
    - 하나의 케이블처럼 보이지만 실제로는 8개의 구리선 두개씩 꼬아서 묶음
    - 구리선을 실드 처리하지 않고 덮은 UTP 케이블과 실드 처리하고 덮은 STP로 나누어짐 (우리가 많이 보는 케이블은 UTP 케이블로 LAN 케이블이라고 흔히 말함)
  - 광섬유 케이블
    - 레이저 이용해 통신하기 때문에 구리선과는 비교할 수 없을 만큼 장거리 및 고속 통신이 가능 (보통 100Gbps)
    - 광섬유 내부와 외부를 다른 밀도 가지는 유리나 플라스틱 섬유로 제작 → 한번 들어간 빛이 내부에서 계속적으로 반사
    - 빛의 굴절율이 높은 부분: core, 빛의 굴절율이 낮은 부분: cladding
    
    ![image-2](https://github.com/CS-STUDY-17/CS-Study/assets/86969518/5d853ff3-373a-4b78-a121-8d41945441ee)

#### 무선 LAN (IEEE802.11)
수신과 송신에 같은 채널 사용함 → 반이중화 통신
- 반이중화(half duplex) 통신
  - 양쪽 장치는 서로 통신할 수 있지만, 동시에 통신 X, 한 번에 한 방향만 통신 가능
  - 데이터 수신 중이면 전송 제한됨
  - 동시에 전송하면 충돌이 발생해 메시지가 손실되거나 왜곡될 수 있어서 충돌 방지 시스템 필요
- CSMA/CA
  - 반이중화 통신 중 하나
  - 데이터 보내기 전 캐리어 감지 등으로 사전에 가능한 한 충돌을 방지하는 방식
  - 과정
    1. 데이터 송신하기 전 무선 매체 살핌
    2. 캐리어 감지: 회선 비어있는지 판단
    3. IFS(Inter FrameSpace): 랜덤 값 기반으로 정해진 시간만큼 기다리며, 만약 무선 매체가 사용 중이면 점차 그 간격 늘려가며 기다림
    4. 이후 데이터 송신
- 무선 LAN 이루는 주파수: 2.4GHz, 5GHz 중 하나
  - 2.4GHz: 장애물에 강하지만 전파 간섭 일어나는 경우 많음
  - 5GHz: 사용할 수 있는 채널 수 많고 동시에 사용 가능, 상대적으로 깨끗한 전파 환경
  - 그래서 보통은 5GHz 쓰는게 좋음
  
  <br>

  - 와이파이
    - 전자기기들이 무선 LAN 신호에 연결할 수 있게 하는 기술
    - 무선 접속 장치 (AP, Access Point)가 필요 = 공유기
      - 이를 통해 유선 LAN에 흐르는 신호를 무선 LAN 신호로 바꿔줌
    - 와이파이 이외에 무선 LAN 이용한 기술로는 지그비, 블루투스 등이 있다.
  - BSS(Basic Service Set)
    - 기본 서비스 집합
    - 단순 공유기를 통해 네트워크에 접속하는 것이 아닌 동일 BSS 내에 있는 AP 들과 장치들이 서로 통신이 가능한 구조
    - 근거리 무선 통신
    - 하나의 AP만을 기반으로 구축 → 사용자가 이동하며 네트워크에 접속하는 것은 불가능
  - ESS(Extended Service Set)
    - 하나 이상의 연결된 BSS 그룹
    - 장거리 무선 통신
    - 더 많은 가용성과 이동성 지원 (사용자 이동 가능)

<br>

- 이더넷 프레임
  - 데이터 링크 계층은 이더넷 프레임을 통해 전달받은 데이터의 에러를 검출하고 캡슐화함

![2965_1](https://github.com/CS-STUDY-17/CS-Study/assets/86969518/c62fd5b8-9108-448a-b2a7-300108ecd60f)

1. Preamble: 이더넷 프레임이 시작임을 알림
2. SFD(Start Frame Delimiter): 다음 바이트부터 MAC 주소 필드가 시작됨을 알림
3. DMAC, SMAC (DA, SA): 수신, 송신 MAC 주소
4. EtherType: 데이터 계층 위의 계층인 ip 프로토콜을 정의 (ex: ipv4, ipv6)
5. Payload(Data + Padding): 전달받은 데이터
6. CRC(FCS, Frame Check Sequence): 에러 확인 비트

** MAC 주소: 컴퓨터나 노트북 등 각 장치에는 네트워크에 연결하기 위한 장치(LAN 카드)가 있는데, 이를 구별하기 위한 식별번호. 6바이트(48비트)로 구성

#### 계층 간 데이터 송수신 과정
캡슐화 → 링크 게층 통해 해당 서버와 통신 → 비캡슐화 
![image](https://github.com/CS-STUDY-17/CS-Study/assets/86969518/e2b8c42f-029d-4cb1-83ab-46e7721629c9)

캡슐화 과정: 상위 계층의 헤더와 데이터를 하위 계층의 데이터 부분에 포함시키고 해당 계층의 헤더를 삽입하는 과정  
각 계층마다 캡슐화 결과 부르는 명칭이 다름 (바로 뒤 PDU 참고)
![image-3](https://github.com/CS-STUDY-17/CS-Study/assets/86969518/c0d7da7c-36f5-4bf7-8e4c-ebe20c8fc137)

비캡슐화 과정: 캡슐화 과정의 반대, 하위 계층에서 상위 계층으로 가며 각 계층의 헤더 부분을 제거하는 과정
### PDU
> 네트워크의 어떠한 계층에서 계층으로 데이터가 전달될 때 한 덩어리의 단위를 의미 (Protocol Data Unit)
- 제어 관련 정보 포함된 <b>헤더</b>, 데이터를 의미하는 <b>페이로드</b>로 구성됨
- 각 계층마다 부르는 명칭이 다름

| 계층                  | PDU                       |
|---------------------|---------------------------|
| 애플리케이션(application) | 메시지, 데이터                  |
| 전송(transport)       | 세그먼트(TCP), 데이터그램(UDP)     |
| 인터넷(internet)       | 패킷                        |
| 링크(link)            | 프레임(데이터 링크 계층), 비트(물리 계층) |

> 참고로 PDU 중 아래 계층인 비트로 송수신하는 것이 모든 PDU 중 가장 빠르고 효율적이다   
> 하지만 애플리케이션 계층에서는 문자열을 기반으로 송수신을 하는데, 그 이유는 헤더에 authorization 값 등 다른 값들 넣는 확장이 쉽기 때문

## 네트워크 기기
- 계층별로 처리 범위 나눌 수 있음
- 상위 계층 처리하는 기기는 하위 계층 처리 가능, 반대는 불가능

| 계층                  | 네트워크 기기      |
|---------------------|--------------|
| 애플리케이션(application) | L7 스위치       |
| 전송(transport)       | 라우터, L3 스위치  |
| 인터넷(internet)       | L2 스위치, 브리지  |
| 링크(link)            | NIC, 리피터, AP |

<br>

> 스위치는 여러 장비를 연결하고 데이터 통신을 중개하며 목적지가 연결된 포트로만 전기 신호를 보내 데이터를 전송하는 통신 네트워크 장비

#### L7 스위치
- 애플리케이션 계층 처리
- 로드 밸런서, 서버의 부하를 분산하는 기기이다 (Application Load Balancer)
- 클라이언트로부터 오는 요청들을 뒤쪽의 여러 서버로 나누는 역할
- 시스템이 처리할 수 있는 트래픽 증가가 목표
- IP, vhxm + URL, HTTP, 헤더, 쿠키 등을 기반으로 트래픽 분산
- 바이러스나 불필요한 외부 데이터 등을 걸러내는 필터링 기능 있음
- 정기적 health check를 통해 장애가 발생한 서버는 트래픽 분산 대상에서 제외시킴

#### L4 스위치
- 전송 계층 처리
- 로드 밸런서 (Network Load Balancer)
- 스트리밍 관련 서비스에서 사용 X, 메시지 기반 인식 X
- IP와 포트 기반(특히 포트 기반) 트래픽 분산

> 로드밸런서 → 서버 이중화  
> 2대 이상의 서버를 기반으로 가상 ip 제공하고, 이를 기반으로 안정적인 서비스 제공

#### 라우터
- 인터넷 계층 처리
- 소프트웨어 기반 라우팅, 하드웨어 기반 라우팅 (= L3 스위치)

> - 라우터는 여러 개의 네트워크를 연결, 분할, 구분시켜주는 역할  
> - 라우팅 = 다른 네트워크에 존재하는 장치끼리 서로 데이터를 주고받을 때 패킷 소모를 최소화 하고 경로를 최적화하여 최소 경로로 패킷을 포워딩

#### L3 스위치
- 인터넷 계층 처리
- L2 스위치의 기능 + 라우팅 기능

#### L2 스위치
- 데이터 링크 계층 처리
- 장치들의 MAC 주소 관리
- 연결된 장치로부터 패킷 왔을 때 패킷 전송 담당
- 목적지가 MAC 주소 테이블에 없다면 전체 포트에 전달하고 MAC 주소 테이블의 주소는 일정 시간 이후 삭제

|        | L2 스위치     | L3 스위치  |
|--------|------------|---------|
| 참조 테이블 | MAC 주소 테이블 | 라우팅 테이블 |
| 참조 PDU | 이더넷 프레임    | IP 패킷   |
| 참조 주소  | MAC 주소     | IP 주소   |

#### 브리지 (bridge)
- 데이터 링크 계층 처리
- 두 개의 근거리 통신망(LAN)을 상호 접속할 수 있도록 하는 통신망 연결 장치
- 통신망 범위 확장하고 서로 다른 LAN 등으로 이루어진 하나의 통신망 구축 시 쓰임
- 장치에서 받아온 MAC 주소 관리 (MAC 주소 테이블)

#### NIC (Network Interface Card)
- 물리 계층 처리
- = LAN 카드 (각 LAN 카드에는 고유의 식별 변호인 MAC 주소가 있음)
- 2대 이상의 컴퓨터 네트워크를 구성하는데 사용
- 네트워크와 빠른 속도로 데이터를 송수신할 수 있도록 컴퓨터 내에 설치하는 확장 카드

#### 리피터 (repeater)
- 물리 계층 처리
- 들어오는 약해진 신호 정도 증폭해 다른 쪽으로 전달하는 장치
- 패킷이 더 멀리 갈 수 있음
- 광케이블 보급되면서 잘 안 씀

#### AP (Access Point)
- 패킷을 복사하는 기기
- AP에 유선 LAN을 연결한 후 다른 장치에서 무선 LAN 기술을 사용해 무선 네트워크 연결 가능

## IP 주소
- 인터넷 계층에서 사용됨

### ARP (Address Resolution Protocol)
- 컴퓨터와 컴퓨터 간의 통신: ip 기반 (= ip 주소에서 ARP를 통해 MAC 주소를 찾아 MAC 주소를 기반으로 통신)
- ARP란 ip 주소(가상 주소, 논리적 주소)로부터 MAC 주소(실제 주소, 물리적 주소) 구하는 ip와 MAC 주소의 다리 역할 하는 프로토콜
- 반대로 MAC 주소에서 ip 주소 변환하는 프로토콜은 RARP

### 홉바이홉(hop by hop) 통신
- ip 주소를 통해 통신하는 과정
- 통신망에서 각 패킷이 여러 개의 라우터를 건너가는 모습을 표현한 것

![107](https://github.com/CS-STUDY-17/CS-Study/assets/86969518/d1cc9a7a-f3c6-4866-91ba-4323dff4bb85)

- 통신 장치에 있는 라우팅 테이블의 ip를 통해 라우팅 과정을 거쳐 패킷이 최종 목적지까지 도달하는 통신
  - 라우팅: 시작 주소부터 시작해 다음 ip로 계속해서 이동하는 과정, ip 주소를 찾아가는 과정

#### 라우팅 테이블
- 송신지에서 수신지까지 도달하기 위해 사용
- 게이트웨이, 모든 목적지에 대해 해당 목적지에 도달하기 위해 거쳐야 할 다음 라우터 정보의 리스트
- netstat -r 통해 확인 가능

#### 게이트웨이
- 서로 다른 통신망, 프로토콜을 사용하는 네트워크 간의 통신을 가능하게 하는 관문 역할을 하는 컴퓨터나 소프트웨어를 두루 일컫는 용어

### IP 주소 체계
- IPv4
  - 32비트를 8비트 단위로 점을 찍어 표기 ex) 123.45.67.89
  - 현재 가장 많이 쓰이는 주소 체계
- IPv6
  - 64비트를 16비트 단위로 점을 찍어 표기 ex) 2001:db8::ff00:42:8329
  - 이쪽으로 가는 추세

#### 클래스 기반 할당 방식 (classful network addressing)
- A, B, C, D, E 5개의 클래스로 구분
- 앞에 있는 부분 - 네트워크 주소, 뒤에 있는 부분 - 호스트 주소(컴퓨터에 부여)

![110_1](https://github.com/CS-STUDY-17/CS-Study/assets/86969518/46dea4a7-8679-4fdb-86a5-400cbc15f408)

| 클래스   | 사용되는 곳      | 범위                |
|-------|-------------|-------------------|
| 클래스 A | 일대일 통신      | 0.0.0.0 ~ 127.255.255.255 |
| 클래스 B | 일대일 통신      | 128.0.0.0 ~ 191.255.255.255|
| 클래스 C | 일대일 통신      | 192.0.0.0 ~ 223.255.255.255 |
| 클래스 D | 멀티캐스트 통신    |                   |
| 클래스 E | 앞으로 사용할 예비용 |                   |

- 맨 왼쪽에 있는 비트 = 구분 비트
  - 클래스 A: 0
  - 클래스 B: 10
  - 클래스 C: 110

- 사용하는 주소보다 버리는 주소가 많은 단점 ➡️ DHCP, IPv6, NAT

#### DHCP (Dynamic Host Configuration Protocol)
- ip 주소 및 기타 통신 매개변수를 자동으로 할당하기 위한 네트워크 관리 프로토콜
- 네트워크 장치의 ip 주소를 수동으로 설정할 필요 없이 인터넷에 접속할 때마다 자동으로 ip 주소 할당

#### NAT (Network Address Translation)
- 패킷이 라우팅 장치를 통해 전송되는 동안 패킷의 ip 주소 정보를 수정해 ip 주소를 다른 주소로 매핑하는 방법
- 공인 ip, 사설 ip 나눔 (IPv4 주소 체계만으로는 많은 주소를 모두 감당하지 못하는 단점 해결)
  - 하나의 공인 ip로 각각 다른 ip처럼 사용 (사설 ip로 변환)
- ICS, RRAS, Netfilter 등의 소프트웨어로 NAT 가능
- 공유기에 NAT 기능 탑재됨 (하나의 공유기(하나의 인터넷 회선)에 여러 pc 연결)
- 외부에 드러나는 ip 주소, 내부 네트워크에서 사용되는 ip 주소 다르게 → 보안 효과
- 인터넷 속도 느려질 수 있다는 단점

### IP 주소를 이용한 위치 정보
- ip 주소로 위치추적 가능

## HTTP
- 애플리케이션 계층으로서 웹 서비스 통신에 사용됨

### HTTP/1.0
- 한 연결당 하나의 요청 처리 ➡️ RTT 증가
- 서버로부터 파일을 가져올 때마다 3-way handshake 계속해서 해야 하기 때문
- RTT = 패킷이 목적지에 도달하고 나서 다시 출발지로 돌아오기까지 걸리는 시간 (패킷 왕복 시간)

#### RTT 증가 해결 위해..
- 이미지 스플리팅
  - 많은 이미지 다운로드 대신 많은 이미지 합쳐 있는 하나의 이미지 다운로드 받기
  - background-image의 position을 이용해 이미지를 표기함
- 코드 압축
  - 코드를 압축(개행문자, 빈칸 없애기)해 코드의 용량을 최소화함
- 이미지 Base64 인코딩
  - 이미지 파일을 64진법 문자열로 인코딩
  - 이미지를 서버에 요청할 필요 없음 (3-way handshake 안해도 됨)
  - 37%정도 크기가 더 커지는 단점 있음

### HTTP/1.1
- Connection: keep-alive (한번 TCP 연결 한 이후 여러개 파일 송수신 가능)
- HTTP/1.0 에서도 keep-alive 옵션 있긴 했지만 표준화되어있지 않았음
- 그림: HTTP/1.0 vs HTTP/1.1 비교

![R1280x0](https://github.com/CS-STUDY-17/CS-Study/assets/86969518/c3a5b10a-01bf-476c-b592-2b90b125a3ba)

- 단점: 문서 안에 이미지, 동영상, css 파일, js 파일 등 리소스의 개수에 비해 대기 시간이 길어진다

> #### HOL Blocking (Head of Line Blocking)
> 네트워크에서 같은 큐에 있는 패킷이 그 첫번째 패킷에 의해 지연될 때 발생하는 성능 저하 현상
> 
> ![R1280x0](https://github.com/CS-STUDY-17/CS-Study/assets/86969518/859236b3-2ecc-41ee-99ff-c1381dfc72ef)
> HTTP 요청은 순차 처리되기 때문에 두번째, 세번째 요청이 일찍 끝날 수 있어도 첫번째 요청이 끝나기 전까지 안 끝남  
> 참고) 요청이 완료되기 전 연속으로 여러 요청 보낼 수 있는 것은 Pipelining 이다

- HTTP/1.1은 무거운 헤더구조를 가짐 (헤더에 쿠키 등 많은 메타 데이터가 들어있고 압축이 되지 않아서)

### HTTP/2
- HTTP/1.x 보다 지연 시간을 줄이고 응답 시간을 더 빠르게

#### 멀티플렉싱
- 여러 개의 스트림 사용해 송수신
- 단일 연결을 사용해 병렬로 여러 요청을 받을 수 있고 응답 줄 수 있음
- HOL Blocking 해결

#### 헤더 압축
- 허프만 코딩 압축 알고리즘 사용하는 HPACK 압축 형식 가짐
  - 허프만 코딩: 문자열을 문자 단위로 쪼개 빈도가 높은 정보는 적은 비트 수로, 빈도가 낮은 정보는 비트 수를 많이 사용해 표현
  - 전체 데이터의 표현에 필요한 비트양을 줄이는 원리
- HTTP/1.x의 무거운 헤더 구조 해결

#### 서버 푸시
- 클라이언트 요청 없이 서버가 바로 리소스 푸시 가능 (HTTP/1.1에서는 클라이언트가 서버에 요청해야 파일 다운로드 가능)

<img width="810" alt="스크린샷 2023-11-09 오전 5 42 31" src="https://github.com/CS-STUDY-17/CS-Study/assets/86969518/42455eab-7b4d-414b-bdda-a42f8e398bf6">

### HTTPS
- 신뢰할 수 있는 HTTP 요청 (애플리케이션 계층과 전송 계층 사이에 신뢰 계층인 SSL/TLS 계층을 넣음) ➡️ 통신을 암호화
- HTTP/2는 HTTPS 위에서 동작
- 구축 방법
  - 방법 1) 직접 CA에서 구매한 인증키 기반으로 HTTPS 서비스를 구축
  - 방법 2) 서버 앞단의 HTTPS 제공 로드밸런서 두기
  - 방법 3) 서버 앞단에 HTTPS 제공 CDN 두기
  
#### SSL/TLS
- 전송 계층에서 보안을 제공
- 클라이언트와 서버가 통신할 때 인터셉터 방지 (제 3자가 메시지를 도청하거나 변조하지 못하도록)


- 보안 세션
  - 보안이 시작되고 끝나는 동안 유지되는 세션
  - SSL/TLS는 핸드셰이크를 통해 보안 세션을 생성하고 이를 기반으로 상태 정보 등 공유
  1. 클라이언트에서 사이퍼 슈트를 서버에 전달
  2. 서버는 받은 사이퍼 슈트의 암호화 알고리즘 리스트를 제공할 수 있는지 확인
  3. 제공할 수 있다면 인증 메커니즘 시작(클라이언트로 인증서 보내기)
  4. 해싱 알고리즘 등으로 암호화된 데이터의 송수신

```angular2html
사이퍼 슈트: 프로토콜, AEAD 사이퍼 모드, 해싱 알고리즘이 나열된 규악
ex) TLS_AES_128_GCM_SHA256
TLS - 프로토콜, AES_128_GCM - AEAD 사이퍼 모드, SHA256 - 해싱 알고리즘
```

```angular2html
인증 메커니즘:
CA(Certificate Authorities)에서 발급한 인증서 기반 (CA는 신뢰성이 엄격하게 공인된 기업만 참여 가능)
CA 인증서는 클라이언트에게 공개키 제공하고 서버가 신뢰할 수 있는 서버임을 보장
인증서는 서비스 정보, 공개키, 지문, 디지털 서명으로 이루어짐
```

```angular2html
암호화 알고리즘
키 교환 알고리즘 - 대수곡선 기반의 ECDHE, 모듈식 기반의 DHE
둘다 디피-헬만 근간
```
디피-헬만 키 교환 암호화 알고리즘
![dhkx svg](https://github.com/CS-STUDY-17/CS-Study/assets/86969518/a0ba4865-317c-4a22-adfb-ca6ee673eafe)
공통의 암호키인 PSK(Pre-Shared Key) 생성 - 악의적인 공격자가 개인키 또는 공개키를 가지고도 PSK가 없어서 아무것도 못함

```angular2html
해싱 알고리즘: 데이터를 추정하기 힘든 더 작고, 섞여 있는 조각으로 만드는 알고리즘
SSL/TLS은 SHA-256, SHA-384 알고리즘 사용 (SHA-256 많이 사용)

SHA-256: 해시 함수의 결과값이 256비트인 알고리즘
비트코인, 많은 블록체인 시스템에서도 사용
해싱을 해야 할 메시지에 1을 추가하는 등 전처리를, 전처리된 메시지 기반으로 해시 반환
```

참고) TLS 1.3은 사용자가 이전에 방문한 사이트로 다시 방문한다면 SSL/TLS에서 보안 세션을 만들 때 걸리는 통신을 다시 하지 않아도 됨 (0-RTT)

#### SEO(검색 엔진 최적화) 설정
사이트 내 모든 요소가 동일하다면 HTTPS 서비스를 하는 사이트가 순위가 더 높음

그 외 SEO 설정 위해
- 캐노니컬 설정
- 페이지 속도 개선
- 사이트 맵 관리

### HTTP/3
- TCP 위에서 돌아가는 HTTP/2와 달리 HTTP/3은 UDP 기반의 QUIC이라는 계층 위에서 돌아감
- 멀티플렉싱
- 초기 연결 설정 시 지연 시간 감소
  - QUIC은 TCP 사용 안하기 때문에 3-way handshake 안해서 시간 단축
  - 첫 연결 설정에 1-RTT만 소요
- QUIC에는 순방향 오류 수정 메커니즘(FEC, Forward Error Connection)이 적용됨.
  - 전송 패킷이 손실되면 수신 측에서 에러를 검출하고 수정