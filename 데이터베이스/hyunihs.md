# 데이터베이스
## 데이터베이스의 기본
- DB(Database): 일정한 규칙, 혹은 규악을 통해 구조화되어 저장되는 데이터의 모음집
- DBMS(Database Management System): 해당 데이터베이스를 제어, 관리하는 통합 시스템
- DB안의 데이터는 특정 DBMS마다 정의된 쿼리 언어를 통해 삽입, 삭제, 수정, 조회 가능
- 데이터베이스는 실시간 접근, 동시공유 가능

<img width="860" alt="dbms-image-1" src="https://github.com/CS-STUDY-17/CS-Study/assets/86969518/9cb514c6-8a5b-4462-9035-e34819229835">

### 엔터티(entity)
사람, 장소, 물건, 사건, 개념 등 여러 개의 속성을 지닌 명사

#### 약한 엔터티와 강한 엔터티
- A가 혼자서는 존재할 수 없고 B 엔터티의 존재 여부에 따라 종속적이라면 A는 약한 엔터티, B는 강한 엔터티
- ex) 건물: 강한 엔터티, 방: 약한 엔터티

### 릴레이션(relation)
데이터베이스에서 정보를 구분하여 저장하는 기본 단위
엔터티 데이터 → 릴레이션 하나에 담아 관리
- 관계형 DB: 테이블 (MySQL: 레코드-테이블-데이터베이스)
- NoSQL DB: 컬렉션 (MongoDB: 도큐먼트-컬렉션-데이터베이스)

### 속성(attribute)
릴레이션에서 관리하는 구체적이며 고유한 이름을 갖는 정보  
ex) 엔티티: 차, 속성: 차 넘버, 바퀴 수, 차 색깔, 차종

### 도메인(domain)
각각의 속성들이 가질 수 있는 값의 집합  
ex) 속성: 성별, 도메인: {남, 여}

### 필드와 레코드
- 레코드(튜플) = 테이블의 행(row) 단위 데이터

#### 필드 타입
- DBMS마다 다름
- 숫자, 날짜, 문자 타입 등

#### 문자 타입
- CHAR: 고정 길이 문자열
- VARCHAR: 가변 길이 문자열
- TEXT: 큰 문자열 저장
- BLOB: 이미지 동영상 저장
  - 그러나 보통은 s3에 파일 올리고 그 경로를 VARCHAR로 저장
- ENUM: 열거형
  - 단일 선택만 가능
  - 잘못된 값 삽입 시 빈 문자열이 대신 삽입됨
  - 숫자로 매핑되어 메모리 적게 사용하는 이점
  - 최대 65,535개의 요소
- SET: 열거형
  - 여러개 선택 가능
  - 비트 단위 연산 가능
  - 최대 64개 요소

### 관계
데이터베이스에는 여러 테이블이 있고 서로의 관계가 정의되어 있음

![img](https://github.com/CS-STUDY-17/CS-Study/assets/86969518/939079bb-075e-46b5-8120-94461b96a44d)

- 1:1 관계
- 1:N 관계
- N:M 관계
  - 1:N, 1:M이라는 관계를 갖는 테이블 두개로 나누어 구축 (중간 테이블 설정)

### 키
#### 기본키(Primary Key)
- 유일성, 최소성
- 자연키
- 인조키: 인위적으로 생성함, 보통 기본키는 인조키로 설정

#### 외래키(Foreign Key)
- 다른 테이블의 기본키를 참조
- 개체와의 관계를 식별하는데에 사용 

#### 후보키(candidate key)
- 기본키가 될 수 있는 후보들(유일성, 최소성 동시 만족)

#### 대체키(alternate key)
- 후보키가 두 개 이상일 경우 어느 하나를 기본키로 지정하고 남은 후보키들

#### 슈퍼키(super key)
- 각 레코드를 유일하게 식별할 수 있는 유일성을 갖춘 키

## ERD와 정규화 과정
> ERD(Entity Relationship Diagram): 릴레이션 간의 관계들을 정의한 것

### ERD의 중요성
- 시스템의 요구 사항을 기반으로 작성됨
- ERD 기반으로 DB 구축
- 디버깅 또는 비즈니스 프로세스 재설계가 필요한 경우 설계도 역할 담당
- 관계형 구조 표현에는 유리하지만 비정형 데이터를 충분히 표현 못한다는 단점

#### 예시
![image-7](https://github.com/CS-STUDY-17/CS-Study/assets/86969518/d3957779-794d-48ea-9506-bec2fecd9d66)

### 정규화 과정
- 릴레이션 간의 잘못된 종속 관계로 인해 DB 이상 현상이 일어나 이를 해결하거나,  
저장 공간을 효율적으로 사용하기 위해 릴레이션을 여러 개로 분리하는 과정
- 정규형 원칙을 기반으로 정규형(NF, Normal Form)을 만들어가는 과정

#### 정규형 원칙
> - 같은 의미를 표현하는 릴레이션이지만 좀 더 좋은 구조로 만들어야
> - 자료의 중복성은 감소해야
> - 독립적인 관계는 별개의 릴레이션으로 표현해야
> - 각각의 릴레이션은 독립적 표현이 가능해야

- 제 1 정규형: 릴레이션의 속성 값은 하나의 값만 가져야 (모든 도메인이 atomic value로 구성)
- 제 2 정규형: 제 1 정규형이며 부분 함수의 종속성을 제거한 형태
  - 부분 함수의 종속성 제거: 기본키가 아닌 모든 속성이 기본키에 완전 함수 종속적인 것
![R1280x0-9](https://github.com/CS-STUDY-17/CS-Study/assets/86969518/1aaf9d84-d562-431a-b208-42e9673100cc)
![R1280x0-10](https://github.com/CS-STUDY-17/CS-Study/assets/86969518/8f1d038a-3532-45b6-a8a9-4ffc671a3d67)
➡ 릴레이션 분리: 사원번호, 직책, 부서번호 / 사원번호, 사원이름, 주소, 전화번호 / 부서번호, 부서이름
  - 동등한 릴레이션으로 분리해야
  - 무손실 분해 (정보 손실 X)
- 제 3 정규형: 제 2 정규형이며 기본키가 아닌 모든 속성이 이행적 함수 종속(transitive FD) 만족하지 않는 상태
  - 이행적 함수 종속: A→B, B→C 이면 A→C 성립 ➡ 이때, 집합 C가 집합 A에 이행적으로 함수 종속이 되었다고 함
<img width="474" alt="172173196-3ae4718c-06de-4b03-948e-41ffef7ba24b" src="https://github.com/CS-STUDY-17/CS-Study/assets/86969518/6e5cc64e-6e5a-436d-8926-8b5f82bdd21e">
위와 같이 릴레이션 분해하는 것
- 보이스/코드 정규형 (BCNF): 제 3 정규형이며 모든 결정자가 후보키인 상태
  - 결정자: X→Y에서 X는 결정자, Y는 종속자.  
    함수 종속 관계에서 특정 종속자(dependent)를 결정짓는 요소
<img width="773" alt="172179846-3fbac11a-6583-46b0-8518-99b24a12cfc2" src="https://github.com/CS-STUDY-17/CS-Study/assets/86969518/29a9e0e5-936c-4f83-8d18-10cac1598574">
<img width="485" alt="172179927-565b3960-7405-4369-97aa-6ea6cb5b7ab7" src="https://github.com/CS-STUDY-17/CS-Study/assets/86969518/fe46e769-8267-4ac2-a4e9-4de9c7fa3867">
➡ 강사 속성이 결정자이지만 후보키가 아님 → 테이블 분리  
➡ 보이스/코드 정규화 만족, 학번에 NULL 들어가는 삽입 이상 해결

> 정규형 과정을 거쳐 테이블 나눈다고 해서 성능이 100% 좋아지는 것은 아님.  
> 좋아질 수도 있고 나빠질 수도 있음.  
> 쿼리 조인 때문에 느려질 수도 있어서 서비스에 따라 정규화/비정규화 진행해야!