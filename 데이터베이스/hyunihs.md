# 데이터베이스
## 데이터베이스의 기본
- DB(Database): 일정한 규칙, 혹은 규악을 통해 구조화되어 저장되는 데이터의 모음집
- DBMS(Database Management System): 해당 데이터베이스를 제어, 관리하는 통합 시스템
- DB안의 데이터는 특정 DBMS마다 정의된 쿼리 언어를 통해 삽입, 삭제, 수정, 조회 가능
- 데이터베이스는 실시간 접근, 동시공유 가능

<img width="860" alt="dbms-image-1" src="https://github.com/CS-STUDY-17/CS-Study/assets/86969518/9cb514c6-8a5b-4462-9035-e34819229835">

### 엔터티(entity)
사람, 장소, 물건, 사건, 개념 등 여러 개의 속성을 지닌 명사

#### 약한 엔터티와 강한 엔터티
- A가 혼자서는 존재할 수 없고 B 엔터티의 존재 여부에 따라 종속적이라면 A는 약한 엔터티, B는 강한 엔터티
- ex) 건물: 강한 엔터티, 방: 약한 엔터티

### 릴레이션(relation)
데이터베이스에서 정보를 구분하여 저장하는 기본 단위
엔터티 데이터 → 릴레이션 하나에 담아 관리
- 관계형 DB: 테이블 (MySQL: 레코드-테이블-데이터베이스)
- NoSQL DB: 컬렉션 (MongoDB: 도큐먼트-컬렉션-데이터베이스)

### 속성(attribute)
릴레이션에서 관리하는 구체적이며 고유한 이름을 갖는 정보  
ex) 엔티티: 차, 속성: 차 넘버, 바퀴 수, 차 색깔, 차종

### 도메인(domain)
각각의 속성들이 가질 수 있는 값의 집합  
ex) 속성: 성별, 도메인: {남, 여}

### 필드와 레코드
- 레코드(튜플) = 테이블의 행(row) 단위 데이터

#### 필드 타입
- DBMS마다 다름
- 숫자, 날짜, 문자 타입 등

#### 문자 타입
- CHAR: 고정 길이 문자열
- VARCHAR: 가변 길이 문자열
- TEXT: 큰 문자열 저장
- BLOB: 이미지 동영상 저장
  - 그러나 보통은 s3에 파일 올리고 그 경로를 VARCHAR로 저장
- ENUM: 열거형
  - 단일 선택만 가능
  - 잘못된 값 삽입 시 빈 문자열이 대신 삽입됨
  - 숫자로 매핑되어 메모리 적게 사용하는 이점
  - 최대 65,535개의 요소
- SET: 열거형
  - 여러개 선택 가능
  - 비트 단위 연산 가능
  - 최대 64개 요소

### 관계
데이터베이스에는 여러 테이블이 있고 서로의 관계가 정의되어 있음

![img](https://github.com/CS-STUDY-17/CS-Study/assets/86969518/939079bb-075e-46b5-8120-94461b96a44d)

- 1:1 관계
- 1:N 관계
- N:M 관계
  - 1:N, 1:M이라는 관계를 갖는 테이블 두개로 나누어 구축 (중간 테이블 설정)

### 키
#### 기본키(Primary Key)
- 유일성, 최소성
- 자연키
- 인조키: 인위적으로 생성함, 보통 기본키는 인조키로 설정

#### 외래키(Foreign Key)
- 다른 테이블의 기본키를 참조
- 개체와의 관계를 식별하는데에 사용 

#### 후보키(candidate key)
- 기본키가 될 수 있는 후보들(유일성, 최소성 동시 만족)

#### 대체키(alternate key)
- 후보키가 두 개 이상일 경우 어느 하나를 기본키로 지정하고 남은 후보키들

#### 슈퍼키(super key)
- 각 레코드를 유일하게 식별할 수 있는 유일성을 갖춘 키

## ERD와 정규화 과정
> ERD(Entity Relationship Diagram): 릴레이션 간의 관계들을 정의한 것

### ERD의 중요성
- 시스템의 요구 사항을 기반으로 작성됨
- ERD 기반으로 DB 구축
- 디버깅 또는 비즈니스 프로세스 재설계가 필요한 경우 설계도 역할 담당
- 관계형 구조 표현에는 유리하지만 비정형 데이터를 충분히 표현 못한다는 단점

#### 예시
![image-7](https://github.com/CS-STUDY-17/CS-Study/assets/86969518/d3957779-794d-48ea-9506-bec2fecd9d66)

### 정규화 과정
- 릴레이션 간의 잘못된 종속 관계로 인해 DB 이상 현상이 일어나 이를 해결하거나,  
저장 공간을 효율적으로 사용하기 위해 릴레이션을 여러 개로 분리하는 과정
- 정규형 원칙을 기반으로 정규형(NF, Normal Form)을 만들어가는 과정

#### 정규형 원칙
> - 같은 의미를 표현하는 릴레이션이지만 좀 더 좋은 구조로 만들어야
> - 자료의 중복성은 감소해야
> - 독립적인 관계는 별개의 릴레이션으로 표현해야
> - 각각의 릴레이션은 독립적 표현이 가능해야

- 제 1 정규형: 릴레이션의 속성 값은 하나의 값만 가져야 (모든 도메인이 atomic value로 구성)
- 제 2 정규형: 제 1 정규형이며 부분 함수의 종속성을 제거한 형태
  - 부분 함수의 종속성 제거: 기본키가 아닌 모든 속성이 기본키에 완전 함수 종속적인 것
![R1280x0-9](https://github.com/CS-STUDY-17/CS-Study/assets/86969518/1aaf9d84-d562-431a-b208-42e9673100cc)
![R1280x0-10](https://github.com/CS-STUDY-17/CS-Study/assets/86969518/8f1d038a-3532-45b6-a8a9-4ffc671a3d67)
➡ 릴레이션 분리: 사원번호, 직책, 부서번호 / 사원번호, 사원이름, 주소, 전화번호 / 부서번호, 부서이름
  - 동등한 릴레이션으로 분리해야
  - 무손실 분해 (정보 손실 X)
- 제 3 정규형: 제 2 정규형이며 기본키가 아닌 모든 속성이 이행적 함수 종속(transitive FD) 만족하지 않는 상태
  - 이행적 함수 종속: A→B, B→C 이면 A→C 성립 ➡ 이때, 집합 C가 집합 A에 이행적으로 함수 종속이 되었다고 함
<img width="474" alt="172173196-3ae4718c-06de-4b03-948e-41ffef7ba24b" src="https://github.com/CS-STUDY-17/CS-Study/assets/86969518/6e5cc64e-6e5a-436d-8926-8b5f82bdd21e">
위와 같이 릴레이션 분해하는 것
- 보이스/코드 정규형 (BCNF): 제 3 정규형이며 모든 결정자가 후보키인 상태
  - 결정자: X→Y에서 X는 결정자, Y는 종속자.  
    함수 종속 관계에서 특정 종속자(dependent)를 결정짓는 요소
<img width="773" alt="172179846-3fbac11a-6583-46b0-8518-99b24a12cfc2" src="https://github.com/CS-STUDY-17/CS-Study/assets/86969518/29a9e0e5-936c-4f83-8d18-10cac1598574">
<img width="485" alt="172179927-565b3960-7405-4369-97aa-6ea6cb5b7ab7" src="https://github.com/CS-STUDY-17/CS-Study/assets/86969518/fe46e769-8267-4ac2-a4e9-4de9c7fa3867">
➡ 강사 속성이 결정자이지만 후보키가 아님 → 테이블 분리  
➡ 보이스/코드 정규화 만족, 학번에 NULL 들어가는 삽입 이상 해결

> 정규형 과정을 거쳐 테이블 나눈다고 해서 성능이 100% 좋아지는 것은 아님.  
> 좋아질 수도 있고 나빠질 수도 있음.  
> 쿼리 조인 때문에 느려질 수도 있어서 서비스에 따라 정규화/비정규화 진행해야!

## 트랜잭션과 무결성
### 트랜잭션의 특징 = ACID
- 트랜잭션은 DB에서 하나의 논리적 기능을 수행하기 위한 작업의 단위
- 여러 개의 쿼리들을 하나로 묶는 단위
### 원자성, Atomicity
트랜잭션 안의 쿼리는 무조건 모두 수행되거나 모두 수행되지 않음 (문제 발생 시 롤백되어 모두 수행되지 않음을 보장)

> **커밋과 롤백**
> - 커밋: 하나의 트랜잭션이 성공적으로 처리되면 커밋됨
>   - 변경 내용 영구적으로 DB에 저장
>   - 여러 쿼리가 성공적으로 처리되었다고 확정하는 명령어
> - 커밋 시작 → 트랜잭션 → 커밋종료 (문제발생 시 롤백)
> - 롤백: 트랜잭션 전으로 돌아가기

> **트랜잭션 전파**  
> - 여러 트랜잭션 관련 메서드의 호출을 하나의 트랜잭션에 묶이도록 하는 것
> - Spring 프레임워크에서는 @Transactional annotation 통해 가능

### 일관성, Consistency
데이터는 유효해야 한다 (허용된 방식으로만 데이터를 변경해야 한다)  
예시) A: 100만원, B: 200만원  
A → B 300만원 입금 ➡️ 불가능하므로 일관성 위반

### 독립성(격리성), Isolation
트랜잭션 수행 시 서로 끼어들 수 없음  
복수의 병렬 트랜잭션은 서로 격리되어 마치 순차적으로 실행되는 것처럼 작동되어야 하고, 여러 사용자가 같은 데이터에 접근할 수 있어야
#### 격리 수준
![image](https://github.com/CS-STUDY-17/CS-Study/assets/86969518/7c92e74b-978a-4f91-a9c6-bad384f36031)
![image-2](https://github.com/CS-STUDY-17/CS-Study/assets/86969518/5a32c70e-8080-4c9b-9f12-dd0dabc61966)
- SERIALIZABLE: 트랜잭션을 순차적으로 진행시킴
  - 여러 트랜잭션이 동시에 같은 행 접근 불가
  - 교착 상태 일어날 확률 높고 성능 떨어짐
- REPEATABLE_READ
  - 하나의 트랜잭션이 수정한 행을 다른 트랜잭션이 수정할 수 없도록 막지만, 새로운 행 추가는 막지 않음
- READ_COMMITTED
  - 가장 많이 사용되는 격리 수준 (MySQL 8.0, PostgreSQL, SQL Server, Oracle의 기본값)
  - 커밋 완료된 데이터에 대해서만 조회 허용
  - 하지만 어떤 트랜잭션이 접근한 행 다른 트랜잭션이 수정 가능
- READ_UNCOMMITTED
  - 트랜잭션 커밋 안되어도 조회 가능
  - 하나 트랜잭션 커밋 이전에 다른 트랜잭션에 노출되는 문제 (데이터 무결성 해칠 수 있음)
  - 거대한 양 어림잡아 집계할 때 사용 (빠름)
#### 격리 수준에 따라 발생하는 현상
- 팬텀 리드
- 반복 가능하지 않은 조회
- 더티 리드

### 지속성, Durability
성공적으로 수행된 트랜잭션은 DB 영구 반영  
DB에 시스템 장애 발생해도 원래 상태로 복구하는 회복 기능이 있어야 함
- 체크섬: 중복 검사 방법, 오류 정정 통해 무결성 지킴
- 저널링: 커밋 전에 트랜잭션 등 변경 사항에 대한 로그 남기는 것
- 롤백

### 무결성
데이터의 정확성, 일관성, 유효성 유지하는 것 (DB 신뢰도 위해 필요)
- 개체 무결성: 기본키는 NOT NULL
- 참조 무결성: 참조 관계에 있는 두 테이블 데이터는 일관된 값 유지해야
- 고유 무결성: 고유한 값 가지도록 조건 주어진 경우 고유한 값 (unique)
- NULL 무결성: NOT NULL 조건 주어진 경우 NOT NULL

## 데이터베이스의 종류
### 관계형 데이터베이스(RDBMS)
행과 열을 가지는 표 형식 데이터  
SQL 언어로 조작 (표준 SQL 지키기는 하지만 각 종류에 특화시킨 SQL 사용함)
#### MYSQL
대부분의 운영체제와 호환되며 현재 가장 많이 사용
- 모듈식 아키텍쳐로 쉽게 스토리지 엔진 바꿀 수 있음
- 데이터 웨어하우징, 트랜잭션 처리, 고가용성 처리가 강점
#### PostgreSQL
- 디스크 조각이 차지하는 영영 회수할 수 있는 장치인 VACUUM
- SQL뿐만 아니라 JSON 이용해 데이터 접근 가능

### NoSQL 데이터베이스
SQL을 사용하지 않는 데이터베이스
#### MongoDB
- JSON 통해 데이터 접근 BSON(Binary JSON) 형태로 데이터 저장
- 키-값 데이터 모델에서 확장된 도큐먼트 기반의 데이터베이스
- 확장성 뛰어남
- 빅데이터 저장할 때 성능 좋음
- 스키마 정해놓지 않아서 다양한 도메인의 데이터베이스 기반으로 분석하거나 로깅 등 구현 시 강점
- ObjectId 생성
#### Redis
- 인메모리
- 키-값 데이터 모델 기반
- string이 기본, set, hash 등 지원
- 최대 512MB까지 저장 가능
- 채팅 시스템, 캐싱 계층, 단순 키-값 필요한 세션 정보 관리, 정렬된 셋(sorted set) 자료구조 이용한 실시간 순위표 서비스 등에 사용됨
