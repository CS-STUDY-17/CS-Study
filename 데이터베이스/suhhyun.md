# 데이터베이스
- 데이터베이스: 일정한 규칙, 규약에 따라 구조화되어 저장되는 데이터의 모듬
- DBMS: 데이터베이스를 제어, 관리하는 통합 시스템
- 엔티티: 여러 개의 속성을 가진 명사 (ex. 회원-이름, 아이디, 주소, 전화번호...)
  - 약한 엔티티: 홀로 존재X, 다른 엔티티에 종속적 (ex. 방)
  - 강한 엔티티 (ex. 건물)
- 릴레이션: 데이터베이스에서 정보를 구분하여 저장하는 기본 단위, 
  - 관계형 DB: 테이블-레코드
  - NoSQL: 컬렉션-도큐먼트
- 속성: 릴레이션에서 관리하는 구체적이며 고유한 이름을 갖는 정보
- 도메인: 각각의 속성들이 지닐 수 있는 값의 집합 (ex. 성별 -> {남, 여})

- ENUM: 문자열을 열거한 타입, 최대 65535개의 요소
- SET: 여러 개의 데이터 선택 가능, 비트 단위 연산 가능, 최대 64개의 요소

- 관계
  - 1:1
  - 1:N
  - N:M
- 키
  - 기본키: 최소성, 유일성 만족해야 됨
  - 자연키: 중복된 값(ex. 성별, 이름 등)을 제외하면 자연스럽게 남는 키, 언젠가는 변하는 속성을 지님
  - 인조키: 보통 기본키로 설정됨
  - 외래키: 다른 테이블의 기본키 참조, 개체와의 관계 식별에 사용, 중복 가능
  - 후보키
  - 대체키
  - 슈퍼키

## ERD와 정규화 과정
- ERD: 릴레이션 간의 관계를 정의한 것
### 정규화 과정
- 릴레이션 간의 잘못된 종속 관계에 따른 데이터베이스 이상 현상을 해결하는 과정
  - 한 개의 등급을 가져야 하는 회원이 세 개의 등급을 가질 경우
  - 데이터를 삭제할 때 필요한 다른 데이터가 함께 삭제되는 경우
  - NULL로 인해 데이터 삽입이 불가능한 경우
- 저장 공간을 효율적으로 사용하기 위해 릴레이션을 여러 개로 분리하는 과정

#### 정규형 원칙
- 같은 의미면서 더 좋은 구조
- 자료의 중복성 감소
- 독립적인 관계는 별도의 릴레이션으로 표현
- 각각의 릴레이션은 독립적인 표현이 가능해야 함

#### 제1정규형
- 릴레이션의 모든 도메인이 원자 값으로 구성

#### 제2정규형
- 부분 함수의 종속성을 제거한 형태 -> 기본키가 아닌 모든 속성이 기본키에 완전 함수 종속적인 것
  - 동등한 릴레이션으로 분해
  - 정보 손실 X

#### 제3정규형
- 기본키가 아닌 모든 속성이 이행적 함수 종속을 만족하지 않는 상태
  - 이행적 함수 종속: A->B & B->C -> A->C

#### 보이스/코드 정규형(BCNF)
- 제3정규형
- 결정자가 후보키가 아닌 함수 종속 관계 제거 -> 릴레이션의 함수 종속 관계에서 모든 결정자가 후보키인 상태
  - 결정자: 함수 종속 관계에서 특정 종속자를 결정짓는 요소 (ex. X->Y의 관계에서 X)

**정규형 과정을 거쳐 테이블을 나눌 경우 성능이 나빠질  수도 있음**

## 트랜젝션과 무결성
### 트랜젝션
- 정의: 데이터베이스에서 하나의 논리적 기능을 수행하기 위한 작업의 단위, 여러 개의 쿼리를 하나로 묶는 단위
- 특징: 원자성, 일관성, 독립성, 지속성 (=ACID 특징)

- 원자성: 모두 수행 또는 모두 X를 보장하는 특징
  - ex) 트랜젝션 커밋 후 문제가 생겨 롤백 -> 모두 수행되지 않음을 보장
  - 커밋과 롤백: 데이터 무결성 보장, 변경 사항 쉽게 확인 가능, 작업 그룹화 가능
  - 트랜젝션 전파: 여러 트랜젝션 관련 메서드 호출을 하나의 트랜젝션에 묶이도록 하는 것
- 일관성: 허용된 방식으로만 데이터 변경 가능, DB의 모든 데이터는 여러 조건, 규칙에 따라 유효함을 가져야 함
  - ex) 통장 잔고 -> 마이너스 값 불가능
- 독립성/격리성: 트랜젝션 수행 시 서로 끼어들지 못하는 것, 복수의 병렬 트랜젝션은 순차적으로 작동하는 것처럼 보여야 하지만 실제로 순차적으로 작동하면 성능이 나쁨  
  -> 여러 개의 격리 수준으로 나누어 격리성 보장

| 격리 수준            | 특징                                                             | 추가 특징                       |
|------------------|----------------------------------------------------------------|-----------------------------|
| READ UNCOMMITTED | - 다른 트랜잭션에서 수정 중인 데이터를 읽을 수 있음                                 | 팬텀 리드, 반복 가능하지 않은 조회, 더티 리드 |
| READ COMMITTED   | - 커밋된 데이터만 읽을 수 있음<br/> - 데이터 동시 수정 가능                         | 팬텀 리드, 반복 가능하지 않은 조회        |
| REPEATABLE READ  | - 트랜잭션이 시작될 때 읽은 데이터를 트랜잭션이 종료될 때까지 유지<br/> - 데이터 수정 불가, 추가 가능 | 팬텀 리드                       |
| SERIALIZABLE     | - 트랜잭션이 완전히 완료될 때까지 다른 트랜잭션에서 해당 데이터에 접근 불가                    | - 더티 리드 불가능 (No Dirty Read) |

  - 팬텀 리드: 한 트랜젝션 내에서 동일한 쿼리를 보냈을 때 결과가 다른 경우
  - 반복 가능하지 않은 조회: 한 트랜젝션 내에서 같은 행에 두 번 이상 조회가 발생하고, 그 값이 다른 경우
    - ex) A.count = 1 -> A.count = 2
    - 반복 가능하지 않은 조회: 한 행에 대해서 값이 달라짐(수정/삭제) vs 팬텀 리드: 다른 값이 선택됨(추가/삭제)
  - 더티 리드: 한 트랜젝션이 다른 트랜젝션에 의해 수정되었지만, 아직 커밋되지 않은 행의 데이터를 읽을 수 있을 경우

- 지속성: 성공적으로 수행된 트랜젝션은 영원히 반영되어야 함 -> 복구 기능 필요
  - 체크섬: 중복 검사의 한 형태, 오류 정정을 통해 데이터의 무결성을 보호하는 방법
  - 저널링: 커밋 전 로깅하는 것

### 무결성
- 데이터의 정확성, 일관성, 유효성을 유지하는 것
- 무결성을 유지해야 데이터와 현실 세계의 값의 일치에 신뢰가 생김

- 개체 무결성: 기본키로 선택된 필드는 빈 값 불가능
- 참조 부결성: 참조 관계에 있는 두 테이블의 데이터는 항상 일관된 값을 유지해야 함
- 고유 무결성
- NULL 무결성

## 데이터베이스의 종류
### 관계형 데이터베이스
- 행과 열을 가지는 표 형식 데이터를 저장하는 형태의 데이터베이스
- SQL 언어로 조작

### NoSQL
- Not Only SQL
- SQL을 사용하지 않는 데이터베이스

## 인덱스
- 인덱스: 데이터를 빠르게 찾을 수 있는 하나의 장치
- B-트리: 루트/브랜치/리프 노드로 구성, O(logN)
- 균형 잡힌 트리 구조
- 트리 깊이의 대수확장성

- MySQL
  - 클러스터형 인덱스: primary key 옵션으로 생성
  - 세컨더리 인덱스: create index로 생성, 여러 필드를 기반으로 쿼리를 많이 보낼 때 사용
- MongoDB: 도큐먼트 생성 시 자동으로 object ID(기본키) 부여, 부가 설정으로 복합 인덱스 설정 가능

### 인덱스 최적화 기법
1. 인덱스는 비용이다: 읽기 비용 2번(인덱스, 컬렉션), 수정 반영, 높이 조절, 분산 등 비용 발생
2. 항상 테스팅하라
3. 복합 인덱스-같음, 정렬, 다중 값, 카디널리티

## 조인의 종류
- 내부 조인(inner join)
- 왼쪽 조인(left outer join)
- 오른쪽 조인(right outer join)
- 합집합 조인(full outer join)
**일치하는 항목이 없으면 누락된 부분에 null 표기**

## 조인의 원리
- 중첩 루프 조인: 중첩 for 문과 같은 원리로 행을 하나씩 읽으며 조건에 맞는 조인 실행, 랜덤 접근에 대한 비용 높음 -> 대용량의 테이블에서는 X
- 정렬 병합 조인: 각각의 테이블을 조인할 필드 기준으로 정렬한 후 조인 작업 수행, 적절한 인덱스 없고 대용량의 테이블 조인할 경우, 범위 비교 연산자가 있을 경우 사용
- 해시 조인: 메모리에 테이블을 올려서 실행, 해시 테이블을 기반으로 조인, 동등 조인에서만 사용 가능
  - 빌드 단계: 바이트가 더 작은 테이블을 기반으로 테이블 빌드
  - 프로브 단계: 레코드 읽기 시작, 해시 테이블을 기반으로 일치하는 레코드 찾음

